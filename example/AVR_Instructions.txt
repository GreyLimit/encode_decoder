AVR Instruction Encoding
========================

This data has been distilled from these sources:

	https://en.wikipedia.org/wiki/Atmel_AVR_instruction_set
	
	http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf
	https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-Instruction-Set-Manual-DS40002198A.pdf

In explanation:

	The Wiki page supplied an initial consolidated view of instructions
	encoding, and potentially offered a mechanism to allow analysis of
	the encoding system.
	
	The Microchip Atmel documents, being the final authority on the subject,
	provided the means to verify the content of the resulting data (subject
	to the acknowledgment that I have done this without external confirmation).

The table presented below forms the list which provides the foundation for the
decoding of AVR instructions within the simulator.

Bit assignments: 

rrrrr	= Source register
rrrr	= Source register (R16–R31)
rrr	= Source register (R16–R23)
RRRR	= Source register pair (R1:R0–R31:R30)
ddddd	= Destination register
dddd	= Destination register (R16–R31)
ddd	= Destination register (R16–R23)
DDDD	= Destination register pair (R1:R0–R31:R30)
pp	= Register pair W, X, Y or Z (R25:R24, R27:R26, R29:R28, R31:R30)
aaaaaa	= I/O space address
aaaaa	= I/O space address (first 32 only)
bbb	= Bit number (0–7)
kkkk	= 4-bit unsigned constant (DES opcode)
kkkkkk	= 6-bit unsigned constant
KKKKKKKK= 8-bit constant

AVR Instruction Table
=====================

{ //
{ //	AVR_Decoder.cpp
{ //	===============
{ //
{ //	Containing only the decoder table generated
{ //	by 'encode_decoder' from the data file
{ //	'AVR_instructions.txt'.
{ //
{
{ //
{ //	Include standard stuff.
{ //
{ #include <stdlib.h>
{
{ //
{ //	Include the definitions required for the
{ //	table to compile.
{ //
{ #include "AVR_Decoder.h"
{ #include "AVR_Instructions.h"
{
{ //
{ //	Define the decoder node type.
{ //
{ typedef struct {
{ 	word		mask,		// Which bit do we test (no word index required).
{ 			jump;		// How many to jump if bit is 1.
{ 	function_code	code;		// The routine to return when we complete decoding.
{ \} decoder_entry;
{

{_
{_//
{_//	The lookup function.
{_//
{_function_code decode_opcode( word opcode ) {
{_	decoder_entry	*ptr;
{_	word		test;
{_
{_	ptr = decode_table;
{_	while(( test = ptr->mask )) ptr += ( opcode & test )? ptr->jump: 1;
{_	return( ptr->code );
{_\}
{_
{_//
{_//	EOF
{_//

{Z 16					}
{W 1					}
{L C++					}
{T decoder_entry			}
{S static				}
{N decode_table				}
{F op_					}
{E illegal				}

{I 0000000000000000 nop			} NOP						(No Operation)
{I 00000001DDDDRRRR movw		} MOVW Rd+1:Rd,Rr+1:Rr	Rd+1:Rd = Rr+1:Rr	(Move register pair)
{I 00000010ddddrrrr muls		} MULS Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x signed)

{I 000000110ddd0rrr mulsu		} MULSU Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x unsigned)
{I 000000110ddd1rrr fmul		} FMUL Rd,Rr		R1:R0 = Rd x Rr		(unsigned (1.15) = unsigned (1.7) x unsigned (1.7))
{I 000000111ddd0rrr fmuls		} FMULS Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x signed (1.7))
{I 000000111ddd1rrr fmulsu		} FMULSU Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x unsigned (1.7))

{I 000001rdddddrrrr cpc			} CPC Rd,Rr		Rd - Rr - C		(Compare with Carry)
{I 000010rdddddrrrr sbc			} SBC Rd,Rr		Rd = Rd - Rr - C
{I 000011rdddddrrrr add			} ADD Rd,Rr		Rd = Rd + Rr		(LSL Rd when Rd==Rr)
{I 000100rdddddrrrr cpse		} CPSE Rd,Rr		Skip next instruction if Rd == Rr
{I 000101rdddddrrrr cp			} CP Rd,Rr		Rd - Rr			(Compare)
{I 000110rdddddrrrr sub			} SUB Rd,Rr		Rd = Rd - Rr
{I 000111rdddddrrrr adc			} ADC Rd,Rr		Rd = Rd + Rr + C	(ROL Rd when Rd==Rr)
{I 001000rdddddrrrr and			} AND Rd,Rr		Rd = Rd & Rr
{I 001001rdddddrrrr eor			} EOR Rd,Rr		Rd = Rd ^ Rr
{I 001010rdddddrrrr or			} OR Rd,Rr		Rd = Rd | Rr
{I 001011rdddddrrrr mov			} MOV Rd,Rr		Rd = Rr

{I 0011KKKKddddKKKK cpi			} CPI Rd,K		Rd - K			(Compare with 8-bit immediate)
{I 0100KKKKddddKKKK sbci		} SBCI Rd,K		Rd = Rd - K - C		(Subtract 8-bit immediate and Carry)
{I 0101KKKKddddKKKK subi		} SUBI Rd,K		Rd = Rd - K		(Subtract 8-bit immediate)
{I 0110KKKKddddKKKK ori			} ORI Rd,K		Rd = Rd | K		(Or with 8-bit immediate. Also: SBR Rd,K)
{I 0111KKKKddddKKKK andi		} ANDI Rd,K		Rd = Rd & K		(And with 8-bit immediate. Also: CBR Rd,~K)

{I 1001000ddddd0000 kkkkkkkkkkkkkkkk lds } LDS rd,k		Rd = DS(RAMPD:k)	(Data Space Immediate address)

{I 1001010111001000 lpm_r0		} LPM			R0 = PS(Z)
{I 1001000ddddd0100 lpm_z		} LPM Rd,Z		Rd = PS(Z)
{I 1001000ddddd0101 lpm_zp		} LPM Rd,Z+		Rd = PS(Z+)

{I 1001010111011000 elpm_r0		} ELPM			R0 = PS(RAMPZ:Z)
{I 1001000ddddd0110 elpm_z		} ELPM Rd,Z		Rd = PS(RAMPZ:Z)
{I 1001000ddddd0111 elpm_zp		} ELPM Rd,Z+		Rd = PS(RAMPZ:Z+)

{I 1001000ddddd1100 ld_x		} LD Rd,X		Rd = DS(X)
{I 1001000ddddd1101 ld_xp		} LD Rd,X+		Rd = DS(X+)
{I 1001000ddddd1110 ld_nx		} LD Rd,-X		Rd = DS(-X)
{I 1001000ddddd1111 pop			} POP Rd		Rd = DS(+STACK)

Note:
	Documentation indicates that there are mnemonics for the
	instructions 'LD Rd,Y' and 'LD Rd,Z'.  However examining
	the binary opcode itself, these instructions should be
	recognised as actually being an alias for the instructions
	'LD RD,Y+0' and 'LD Rd,Z+0'

{I 10q0qq0ddddd1qqq ld_y_q		} LD RD,Y+q		Rd = DS(Y+q)			(See Note)
{I 1001000ddddd1001 ld_yp		} LD Rd,Y+		Rd = DS(Y+)
{I 1001000ddddd1010 ld_ny		} LD Rd,−Y		Rd = DS(-Y)

{I 10q0qq0ddddd0qqq ld_z_q		} LD Rd,Z+q		Rd = DS(Z+q)			(See Note)
{I 1001000ddddd0001 ld_zp		} LD Rd,Z+		Rd = DS(Z+)
{I 1001000ddddd0010 ld_nz		} LD Rd,−Z		Rd = DS(-Z)

{I 1001001ddddd0000 kkkkkkkkkkkkkkkk sts } STS k,rd		DS(RAMPD:k) = Rd

{I 1001001ddddd0100 xch			} XCH Z,Rd 		DS(Z) <-> Rd
{I 1001001ddddd0101 las			} LAS Z,Rd		DS(Z) = DS(Z) | Rd, Rd = DS(Z)	(Atomic read and set)
{I 1001001ddddd0110 lac			} LAC Z,Rd		DS(Z) = DS(Z) & ~Rd, Rd = DS(Z)	(Atomic read and clear)
{I 1001001ddddd0111 lat			} LAT Z,Rd		DS(Z) = DS(Z) ^ Rd, Rd = DS(Z)	(Atomic read and toggle)

{I 1001001ddddd1100 st			} ST X,Rd		DS(X) = Rd
{I 1001001ddddd1101 st			} ST X+,Rd		DS(X+) = Rd
{I 1001001ddddd1110 st			} ST -X,Rd		DS(-X) = Rd
{I 1001001ddddd1111 push		} PUSH Rd		DS(STACK-) = Rd

Note:
	Documentation indicates that there are mnemonics for the
	instructions 'ST Y,Rd' and 'ST Z,Rd'.  However examining
	the binary opcode itself, these instructions should be
	recognised as actually being an alias for the instructions
	'ST Y+0,Rd' and 'ST Z+0,Rd'

{I 10q0qq1rrrrr1qqq std_y_q		} STD Y+q,Rd		DS(Y+q) = Rd			(See Note)
{I 1001001ddddd1001 st_yp		} ST Y+,Rd		DS(Y+) = Rd
{I 1001001ddddd1010 st_ny		} ST −Y,Rd		DS(-Y) = Rd

{I 10q0qq1rrrrr0qqq std_z_q		} STD Z+q,Rd		DS(Z+q) = Rd			(See Note)
{I 1001001ddddd0001 st_zp		} ST Z+,Rd		DS(Z+) = Rd
{I 1001001ddddd0010 st_nz		} ST −Z,Rd		DS(-Z) = Rd

{I 1001010000001001 ijmp		} IJMP			PC = Z
{I 1001010000011001 eijmp		} EIJMP			PC = EIND:Z

{I 1001010010001000 clc			} CLC			C = 0
{I 1001010010011000 clz			} CLZ			Z = 0
{I 1001010010101000 cln			} CLN			N = 0
{I 1001010010111000 clv			} CLV			V = 0
{I 1001010011001000 cls			} CLS			S = 0
{I 1001010011011000 clh			} CLH			H = 0
{I 1001010011101000 clt			} CLT			T = 0
{I 1001010011111000 cli			} CLI			I = 0

{I 1001010000001000 sec			} SEC			C = 1
{I 1001010000011000 sez			} SEZ			Z = 1
{I 1001010000101000 sen			} SEN			N = 1
{I 1001010000111000 sev			} SEV			V = 1
{I 1001010001001000 ses			} SES			S = 1
{I 1001010001011000 seh			} SEH			H = 1
{I 1001010001101000 set			} SET			T = 1
{I 1001010001111000 sei			} SEI			I = 1

{I 10010100kkkk1011 des			} DES k			Data Encryption Action 'k'

{I 1001010100001000 ret			} RET			PC = DS(+STACK)		(Pops 2 or 3 bytes as appropriate to AVR architecture)
{I 1001010100001001 icall		} ICALL Z		DS(STACK-) = PC, PC = Z	(Pushes 2 or 3 bytes)
{I 1001010100011000 reti		} RETI			PC = DS(+STACK),I = 1
{I 1001010100011001 eicall		} EICALL Z		DS(STACK-) = PC, PC = EIND:Z

{I 10010101001x1000 reserved		} 			Reserved
{I 1001010101xx1000 reserved		} 			Reserved

{I 1001010110001000 sleep		} SLEEP						(Put CPU into sleep mode)
{I 1001010110011000 break		} BREAK						(Stop CPU, enter debug mode)
{I 1001010110101000 wdr			} WDR						(Restart Watch Dog Timer)
{I 1001010110111000 reserved		} 			Reserved 
{I 1001010111101000 spm			} SPM						(See section 116 in "AVR Instruction Set Manual")
{I 1001010111111000 spm			} SPM Z+ 					(See section 117 in "AVR Instruction Set Manual")

{I 1001010ddddd0000 com			} COM Rd		Rd = ~Rd		(Ones complement)
{I 1001010ddddd0001 neg			} NEG Rd		Rd = -Rd		(Twos complement)
{I 1001010ddddd0010 swap		} SWAP Rd		Rd[0:3] <-> Rd[7:4]	(Swap nibbles in Rd)
{I 1001010ddddd0011 inc			} INC Rd		Rd = Rd + 1		(Increment Rd)
{I 1001010ddddd0100 reserved		} 			Reserved
{I 1001010ddddd0101 asr			} ASR Rd		Rd = Rd / 2		(Arithmetic right shift)
{I 1001010ddddd0110 lsr			} LSR Rd		Rd = Rd >> 1		(Logical right shift)
{I 1001010ddddd0111 ror			} ROR Rd		C -> Rd -> C		(Rotate right Rd through Carry)
{I 1001010ddddd1010 dec			} DEC Rd		Rd = Rd - 1

{I 1001010kkkkk110k kkkkkkkkkkkkkkkk jmp } JMP k		PC = k
{I 1001010kkkkk111k kkkkkkkkkkkkkkkk call } CALL k		DS(STACK-) = PC, PC = k

Note:
	The below 'adiw' and 'sbiw' instructions can be considered to be
	as (mnemonically) operating against the registers W, X, Y or Z.
	In this case the instructions would be viewed as:

		ADIW	[WXYZ],k
	and
		SBIW	[WXYZ],k
		
{I 10010110kkddkkkk adiw		} ADIW Rd,k		Rd+1:Rd += k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value) 
{I 10010111kkddkkkk sbiw		} SBIW Rp,k		Rd+1:Rd -= k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)

{I 10011000aaaaabbb cbi			} CBI a,b		IO(a)[b] = 0		(Clear bit b in IO register a)
{I 10011001aaaaabbb sbic		} SBIC a,b		If IO(a)[b] == 0 skip	(Skip next instruction if bit b in IO register a is clear)
{I 10011010aaaaabbb sbi			} SBI a,b		IO(a)[b] = 1		(Set bit b in IO register a)
{I 10011011aaaaabbb sbis		} SBIS a,b		If IO(a)[b] == 1 skip	(Skip next instruction if bit b in IO register a is set)
{I 100111rdddddrrrr mul			} MUL Rd,Rr		R1:R0 = Rr x Rd		(unsigned = unsigned x unsigned)
{I 10110aadddddaaaa in			} IN Rd,a		Rd = IO(a)		(Output register to IO address)
{I 10111aadddddaaaa out			} OUT a,Rd		IO(a) = Rd		(Read register from IO address)

{I 1100jjjjjjjjjjjj rjmp		} RJMP j		PC = PC + j		(Relative jump, j is signed 12 bit immediate)
{I 1101jjjjjjjjjjjj rcall		} RCALL j		DS(STACK-) = PC, PC = PC + j (Relative call, j is signed 12 bit immediate)
{I 1110KKKKddddKKKK ldi			} LDI Rd,K		Rd = K			(Load register with 8 bit immediate)

{I 111100jjjjjjj000 brcs		} BRCS j		if C == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj001 brzs		} BRZS j		if Z == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj010 brns		} BRNS j		if N == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj011 brvs		} BRVS j		if V == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj100 brss		} BRSS j		if S == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj101 brhs		} BRHS j		if H == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj110 brts		} BRTS j		if T == 1 then PC = PC + j	(j is 7-bit signed offset)
{I 111100jjjjjjj111 bris		} BRIS j		if I == 1 then PC = PC + j	(j is 7-bit signed offset)

{I 111101jjjjjjj000 brcc		} BRCC j		if C == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj001 brzc		} BRZC j		if Z == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj010 brnc		} BRNC j		if N == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj011 brvc		} BRVC j		if V == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj100 brsc		} BRSC j		if S == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj101 brhc		} BRHC j		if H == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj110 brtc		} BRTC j		if T == 0 then PC = PC + j	(j is 7-bit signed offset)
{I 111101jjjjjjj111 bric		} BRIC j		if I == 0 then PC = PC + j	(j is 7-bit signed offset)

{I 1111100ddddd0bbb bld			} BLD Rd,b		Rd[b] = T
{I 1111101ddddd0bbb bst			} BST Rd,b		T = Rd[b]
{I 1111110ddddd0bbb sbrc		} SBRC Rd,b		Skip next if Rd[b] == 0
{I 1111111ddddd0bbb sbrs		} SBRS Rd,b		Skip next if Rd[b] == 1
{I 11111xxddddd1bbb reserved		} 			Reserved

End of Instruction data.
========================
