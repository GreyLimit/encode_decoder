

	#####
	#     #     #    #    #  #    #  #         ##     #####  ######
	#           #    ##  ##  #    #  #        #  #      #    #
	 #####      #    # ## #  #    #  #       #    #     #    #####
	      #     #    #    #  #    #  #       ######     #    #
	#     #     #    #    #  #    #  #       #    #     #    #
	 #####      #    #    #   ####   ######  #    #     #    ######

			   #    #     # ######
			  # #   #     # #     #
			 #   #  #     # #     #
			#     # #     # ######
			#######  #   #  #   #
			#     #   # #   #    #
			#     #    #    #     #

An implementation of an AVR Microcontroller CPU, encoded using the
'encode_decoder' pre-processor for which source code be located at
"https://github.com/GreyLimit/encode_decoder"


Set output language to C++ for the encode_decoder processor.  This needs
to precede any other processor records to ensure consistent output.
{L C++}

AVR Instruction Encoding
========================

This data has been distilled from these sources:

	https://en.wikipedia.org/wiki/Atmel_AVR_instruction_set
	
	http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf
	https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-Instruction-Set-Manual-DS40002198A.pdf

In explanation:

	The Wiki page supplied an initial consolidated view of instructions
	encoding, and potentially offered a mechanism to allow analysis of
	the encoding system (which led to the development of the encode_decoder
	pre-processor program).
	
	The Microchip Atmel documents, being the final authority on the subject,
	provided the specific information on the instructions and their operation.

	While the source of the technical details is authoritative, the accuracy
	of this implementation has to be subject to the acknowledgment that I have
	done this without any external confirmation process (so far).


The Decode Implementation File
==============================

Start the implementation file for the
decoder.

{BS}
//
//	AVR_CPU.cpp
//	-----------
//
//	Containing only the decoder table generated
//	by 'encode_decoder' from the data file
//	'AVR_CPU.txt'.
//

//
//	Include standard stuff.
//
#include <stdlib.h>

//
//	Include the definitions required for the
//	table to compile.
//
#include "AVR_CPU.h"
{B}

The Decode Definitions File
===========================

Set out in the header file the interface to the
decoder.  This is the definition of the AVR CPU
state record.


{BH}
//
//	AVR_CPU.h
//	---------
//

#ifndef _AVR_DECODER_H_
#define _AVR_DECODER_H_

//
//	Include system definitions we need.
//
#include <cstdio>

//
//	Include the base set of definitions (types, constants etc).
//
#include "Base.h"

//
//	Include the hardware object APIs we need.
//
#include "Memory.h"
#include "Flash.h"
#include "Interrupts.h"
#include "Clock.h"
#include "CPU.h"

//
//	Also need to be able to raise software exceptions
//
#include "Exception.h"

//
//	Pre-Declare the Instruction and AVR_CPU classes.
//
//	This is needed as the Instruction and AVR_CPU classes
//	refer to each other.
//
class Instruction;
class AVR_CPU;

//
//	Declare the look up function as defined at the end of
//	the source file.
//
extern Instruction *find_instruction( word opcode );
{B}


{BH}
//
//	Enumerate the various AVR MCUs we shall aim
//	to simulate.
//
typedef enum {
	//
	//	Define the different AVR architectures
	//			
	AVR_MCU		= 0,	// "AVR"	Original instruction set from 1995.
	
	AVRe_MCU	= 1,	// "megaAVR"	Multiply (xMULxx), Move Word (MOVW),
				//		and enhanced Load Program Memory (LPM)
				//		added to the AVR instruction set.
				
	AVRet_MCU	= 2,	// "tinyAVR"	Multiply not included, but else equal
				//		to AVRe for megaAVR ("et" is my label
				//		to apply to this option).
				
	AVRxm_MCU	= 3,	// "XMEGA"	The Read Modify Write (RMW) and
				//		DES encryption instructions are
				//		unique to this version.
				
	AVRxt_MCU	= 4,	// "AVR"	Base AVR from 2016 and onwards.
	
	AVRrc_MCU	= 5	// "tinyAVR"	The Reduced Core AVR CPU.
} AVR_Type;

//
//	Define the number of types we will support (as above).
//
const byte AVR_Types = 6;
{B}

Define the class used to hold the AVR CPU state information, and
provide the CPU class API routines to allow the simulation to be
executed.

{BH}
//
//	The AVR CPU State
//
class AVR_CPU : public CPU {
	private:
		//
		//	Exception handler.
		//
		Exception	*_error;

		//
		//	Which CPU are we?
		//
		AVR_Type	_cpu;

		//
		//	Program address size in BITS and the number of bytes
		//	required to hold that many bits.
		//
		byte		_pas_bits,
				_pas_bytes;
		
		//
		//	Where do we find the program to execute?
		//
		Flash		*_program;

		//
		//	The various element of memory:
		//
		Memory		*_data,
				*_regs,
				*_io,
				*_ext_io,
				*_sram;

		//
		//	Where we collect and manage IRQs.
		//
		Interrupts	*_irqs;

		//
		//	Where the CPU clock is simulated.
		//
		Clock		*_clock;

		//
		//	Transient internal CPU flags.
		//
		bool		_skip_next;		// Step to true to skip next instruction.

		//
		//	The Program Counter
		//	===================
		//
		//	This has no presence in the address space (unlike the
		//	stack pointer and status register), so only needs a
		//	simple variable to hold it.
		//
		//	Also define the mask value which is applied to the PC
		//	to control its range (simulating a fixed number of bits).
		//
		dword		_pc,
				_pc_mask;

		//
		//	The Status Register
		//	===================
		//
		//	Define the IO port where the status register
		//	is found.
		//
		static const word status_register = 0x3F;
		//
		//	Pointer to the Status Register location.
		//
		byte		*_sr;

		//
		//	The Stack Pointer (effectively 16 bit).
		//	=======================================
		//
		//	Define the IO ports where the stack pointer
		//	is found.
		//
		static const word stack_pointer_h = 0x3E;
		static const word stack_pointer_l = 0x3D;
		//
		//	Pointers to the Stack Pointer individual locations.
		//
		byte		*_sp_h,
				*_sp_l;
		//
		//	Private Stack Pointer access routines.
		//
		inline word get_SP( void ) { return( combine( *_sp_h, *_sp_l )); }
		inline void set_SP( word sp ) { *_sp_l = low( sp ); *_sp_h = high( sp ); }

		//
		//	The Extended Indirect Register
		//	==============================
		//
		static const word extended_indirect = 0x3C;
		//
		//	EIND access pointer.
		//
		byte		*_eind;

		//
		//	Extended memory RAM pointer registers
		//	=====================================
		//
		//	Define IO ports where the RAM registers are located.
		//
		static const word ram_z_pointer = 0x3B;
		static const word ram_y_pointer = 0x3A;
		static const word ram_x_pointer = 0x39;
		static const word ram_d_pointer = 0x38;
		//
		//	Define pointers to their actual location in memory.
		//
		byte		*_ram_z,
				*_ram_y,
				*_ram_x,
				*_ram_d;

	public:
		//
		//	AVR_CPU CONSTRUCTOR
		//	=====================
		//
		//	The AVR class emulates a number of AVR class CPUs, selectable
		//	when the object is initialised.
		//
		AVR_CPU(		AVR_Type	cpu,
					byte		pas,		// Program Address size (bits)
					Flash		*program,	
					Memory		*data,
					Memory		*regs,
					Memory		*io,
					Memory		*ext_io,
					Memory		*sram,
					Interrupts	*irqs,
					Clock		*clock,
					Exception	*handler );
{BS}
		//
		//	AVR_CPU CONSTRUCTOR
		//	=====================
		//
		//	The AVR class emulates a number of AVR class CPUs, selectable
		//	when the object is initialised.
		//
		AVR_CPU::AVR_CPU(	AVR_Type	cpu,
					byte		pas,		// Program Address size (bits)
					Flash		*program,	
					Memory		*data,
					Memory		*regs,
					Memory		*io,
					Memory		*ext_io,
					Memory		*sram,
					Interrupts	*irqs,
					Clock		*clock,
					Exception	*handler ) {
			//
			//	CPU type, and program address size in bits and bytes.
			//
			_cpu = cpu;
			_pas_bits = pas;
			_pas_bytes = ( _pas_bits + 7 ) >> 3;
			//
			//	Define the mask applied to the PC every
			//	time it is adjusted.
			//
			_pc_mask = ((dword)1 << _pas_bits ) - 1;
			//
			//	Flashed program memory.
			//
			_program = program;
			//
			//	Memory in its various forms.
			//
			_data = data;
			_regs = regs;
			_io = io;
			_ext_io = ext_io;
			_sram = sram;
			//
			//	Interrupt mechanism
			//
			_irqs = irqs;
			//
			//	The CPU clock
			//
			_clock = clock;
			//
			//	Set CPU flags.
			//
			_skip_next = false;
			//
			//	Save the error handler.
			//
			_error = handler;
			//
			//	Set up Status Register pointer.
			//
			_sr = _io->at( status_register );
			//
			//	Set up the Stack Pointer pointer.
			//
			_sp_h = _io->at( stack_pointer_h );
			_sp_l = _io->at( stack_pointer_l );
			//
			//	The Extended Indirect register
			//
			_eind = _io->at( extended_indirect );
			//
			//	The Extended Memory Registers
			//
			_ram_z = _io->at( ram_z_pointer );
			_ram_y = _io->at( ram_y_pointer );
			_ram_x = _io->at( ram_x_pointer );
			_ram_d = _io->at( ram_d_pointer );
			//
			//	Reset internal registers.
			//
			reset();
		}
{B}
		//
		//	Value Manipulation
		//	------------------
		//
		//	Routines to combine byte, word values up to word
		//	and dword, and split words and dwords down.
		//
		static inline byte high( word v ) { return( v >> 8 ); }
		static inline word highw( dword v ) { return( v >> 16 ); }
		static inline byte low( word v ) { return( v ); }
		static inline word loww( dword v ) { return( v ); }
		static inline word combine( byte h, byte l ) { return( ((word)h << 8 ) | (word)l ); }
		static inline dword combinew( word h, word l ) { return( ((dword)h << 16 ) | (dword)l ); }

		//
		//	Data Registers
		//	==============
		//
		byte read_reg( word reg ) { return( _regs->read( reg )); }
		void write_reg( word reg, byte val ) { _regs->write( reg, val ); }

		//
		//	IO Registers
		//	============
		//
		byte read_io( word io ) { return( _io->read( io )); }
		void write_io( word io, byte val ) { _io->write( io, val ); }

		//
		//	Flash Memory Access
		//	===================
		//
		word read_flash( word adrs ) { return( _program->read( adrs )); }

		//
		//	SRAM Access
		//	===========
		//
		byte read_data( word adrs ) { return( _data->read( adrs )); }
		void write_data( word adrs, byte val ) { _data->write( adrs, val ); }
		byte modify_data( word adrs, byte clear, byte set, byte toggle ) { return( _data->modify( adrs, clear, set, toggle )); }

		//
		//	Status Register
		//	===============
		//
		//	Testing and setting routines.
		//

		//
		//	Get/Set Status register as a whole.
		//
		inline byte get_sr( void ) { return( *_sr ); }
		inline void set_sr( byte val ) { *_sr = val; }
		
		//	I: Global Interrupt Enable
		//	--------------------------
		//
		inline bool get_I( void ) { return( *_sr & 0x80 ); }
		inline void set_I( bool v ) { *_sr = ( *_sr & ~0x80 )|( v? 0x80: 0x00 ); }
		//
		//	T: Bit Copy Storage
		//	-------------------
		//
		inline bool get_T( void ) { return( *_sr & 0x40 ); }
		inline void set_T( bool v ) { *_sr = ( *_sr & ~0x40 )|( v? 0x40: 0x00 ); }
		//
		//	H: Half Carry Flag
		//	------------------
		//
		inline bool get_H( void ) { return( *_sr & 0x20 ); }
		inline void set_H( bool v ) { *_sr = ( *_sr & ~0x20 )|( v? 0x20: 0x00 ); }
		//
		//	S: Sign Bit
		//	-----------
		//
		inline bool get_S( void ) { return( *_sr & 0x10 ); }
		inline void set_S( bool v ) { *_sr = ( *_sr & ~0x10 )|( v? 0x10: 0x00 ); }
		//
		//	V: Two’s Complement Overflow Flag
		//	---------------------------------
		//
		inline bool get_V( void ) { return( *_sr & 0x08 ); }
		inline void set_V( bool v ) { *_sr = ( *_sr & ~0x08 )|( v? 0x08: 0x00 ); }
		//
		//	N: Negative Flag
		//	----------------
		//
		inline bool get_N( void ) { return( *_sr & 0x04 ); }
		inline void set_N( bool v ) { *_sr = ( *_sr & ~0x04 )|( v? 0x04: 0x00 ); }
		//
		//	Z: Zero Flag
		//	------------
		//
		inline bool get_Z( void ) { return( *_sr & 0x02 ); }
		inline void set_Z( bool v ) { *_sr = ( *_sr & ~0x02 )|( v? 0x02: 0x00 ); }
		//
		//	C: Carry Flag
		//	-------------
		//
		inline bool get_C( void ) { return( *_sr & 0x01 ); }
		inline void set_C( bool v ) { *_sr = ( *_sr & ~0x01 )|( v? 0x01: 0x00 ); }

		//
		//	Stack Pointer.
		//	==============
		//
		//	Routines for storing and retrieving data from the stack.
		//
		void push_byte( byte v ) {
			word sp = get_SP();
			_data->write( sp--, v );
			set_SP( sp );
		}
		void push_word( word v ) {
			word sp = get_SP();
			//
			//	Push MSB first to maintain little-endian
			//	data order in memory.
			//
			_data->write( sp--, high( v ));
			_data->write( sp--, low( v ));
			set_SP( sp );
		}
		byte pop_byte( void ) {
			word sp = get_SP();
			byte v = _data->read( ++sp );
			set_SP( sp );
			return( v );
		}
		word pop_word( void ) {
			word sp = get_SP();
			//
			//	Pop LSB first as this is the reverse of
			//	the push action.
			//
			byte l = _data->read( ++sp );
			byte h = _data->read( ++sp );
			set_SP( sp );
			return( combine( h, l ));
		}
		//
		//	Specific PC push and pop routines (as the size of the
		//	program counter varies) and a direct set PC function.
		//
		//	Functions return the number of 'extra' clocks required
		//	to complete the action.
		//
		//	Push also assigns a new value to the PC (as per call).
		//
		word push_pc( dword adrs ) {
			word add = 0;
			switch( _pas_bytes ) {
				case 1: {
					push_byte( low( _pc ));
					break;
				}
				case 2: {
					push_word( _pc );
					add = 1;
					break;
				}
				case 3: {
					push_byte( low( highw( _pc )));
					push_word( loww( _pc ));
					add = 2;
					break;
				}
				default: {
					_error->raise( Invalid_PAS );
				}
			}
			_pc = adrs & _pc_mask;
			return( add );
		}
		word pop_pc( void ) {
			word add = 0;
			switch( _pas_bytes ) {
				case 1: {
					_pc = pop_byte() & _pc_mask;
					break;
				}
				case 2: {
					_pc = pop_word() & _pc_mask;
					add = 1;
					break;
				}
				case 3: {
					_pc = pop_word();
					_pc |= ((dword)pop_byte()) << 16;
					_pc &= _pc_mask;
					add = 2;
					break;
				}
				default: {
					_error->raise( Invalid_PAS );
				}
			}
			return( add );
		}

		//
		//	Program Counter
		//	===============
		//
		//	Routines to obtain and manipulate the program counter register.
		//
		inline void set_pc( dword adrs ) {
			_pc = adrs & _pc_mask;
		}
		inline dword get_pc( void ) {
			return( _pc );
		}
		inline dword pc_rel( dword rel ) {
			return( _pc + rel );
		}
			
		//
		//	Read next program word (move PC forward).
		//
		word next_opcode( void ) {
			word	next;
			//
			//	Simples..
			//
			next = _program->read( _pc );
			_pc = ( _pc + 1 ) & _pc_mask;
			return( next );
		}

		//
		//	Peek ahead into the program with an offset from the PC
		//	Only accepts positive offsets ahead of the PC.
		//
		word peek_ahead( word offset ) {
			//
			//	Simples..
			//
			return( _program->read(( _pc + offset ) & _pc_mask ));
		}

		//
		//	Instruction Skipping Enable
		//	===========================
		//
		//	Mark the next instruction to be executed as "to
		//	be ignored".
		//
		void set_skip_next( void ) {
			_skip_next = true;
		}

		//
		//	Exception handling
		//	==================
		//
		//	Links through back to the Exceptions object pointed
		//	to be '_error'
		//
		bool raise( Errors number ) {
			return( _error->raise( number ));
		}
		bool raise( Errors number, word arg ) {
			return( _error->raise( number, arg ));
		}
		bool raise( Errors number, dword arg1, word arg2 ) {
			return( _error->raise( number, arg1, arg2  ));
		}
		bool raise( Errors number, const char *mesg ) {
			return( _error->raise( number, mesg ));
		}
		bool raise( Errors number, const char *file, word line ) {
			return( _error->raise( number, file, line ));
		}

		//
		//	Extended Memory Register access routines
		//	========================================
		//
		inline byte get_eind( void ) { return( *_eind ); }
		inline byte get_rampz( void ) { return( *_ram_z ); }
		inline byte get_rampy( void ) { return( *_ram_y ); }
		inline byte get_rampx( void ) { return( *_ram_x ); }
		inline byte get_rampd( void ) { return( *_ram_d ); }

		inline void set_eind( byte val ) { *_eind = val; }
		inline void set_rampz( byte val ) { *_ram_z = val; }
		inline void set_rampy( byte val ) { *_ram_y = val; }
		inline void set_rampx( byte val ) { *_ram_x = val; }
		inline void set_rampd( byte val ) { *_ram_d = val; }

		//
		//	Pseudo 16 bit  Registers, W, X, Y and Z.
		//	========================================
		//
		//	These are, really, just aliases for the group
		//	of 8-bit registers at the top of the normal
		//	register set.
		//
		//		Name	Location
		//		----	--------
		//		W	r25:r24
		//		X	r27:r26
		//		Y	r29:r28
		//		Z	r31:r30
		//
		word get_word_reg( word r ) { return( combinew( _regs->read( r+1 ), _regs->read( r ))); }
		inline word get_rw( void ) { return( get_word_reg( 24 )); }
		inline word get_rx( void ) { return( get_word_reg( 26 )); }
		inline word get_ry( void ) { return( get_word_reg( 28 )); }
		inline word get_rz( void ) { return( get_word_reg( 30 )); }
		//
		void set_word_reg( word r, word v ) { _regs->write( r, low( v )); _regs->write( r+1, high( v )); }
		inline void set_rw( word v ) { set_word_reg( 24, v ); }
		inline void set_rx( word v ) { set_word_reg( 26, v ); }
		inline void set_ry( word v ) { set_word_reg( 28, v ); }
		inline void set_rz( word v ) { set_word_reg( 30, v ); }
		//
		word inc_rz( void ) { word z = get_rz(); set_rz( z + 1 ); return( z ); }
		
		//
		//	Pseudo 24 bit  Registers
		//	========================
		//
		//	"Z"
		//
		dword get_rampz_rz( void ) {
			return(( (dword)get_rampz() << 16 ) | (dword)get_rz());
		}
		dword inc_rampz_rz( void ) {
			word z = get_rz();
			byte p = get_rampz();
			word c = z + 1;
			set_rz( c );			// Save incremented z
			if( !c ) set_rampz( p + 1 );	// increment rampz if z rolled to zero.
			return(( (dword)p << 16 ) | (dword)z );
		}
		dword dec_rampz_rz( void ) {
			word z = get_rz() - 1;
			byte p = get_rampz();
			set_rz( z );			// Save decremented z
			if( !z ) set_rampz( p - 1 );	// decrement rampz if z rolled to zero.
			return(( (dword)p << 16 ) | (dword)z );
		}
		dword get_eind_rz( void ) {
			return(( (dword)get_eind() << 16 ) | (dword)get_rz());
		}
		//
		//	"Y"
		//
		dword get_rampy_ry( void ) {
			return(( (dword)get_rampy() << 16 ) | (dword)get_ry());
		}
		dword inc_rampy_ry( void ) {
			word y = get_ry();
			byte p = get_rampy();
			word c = y + 1;
			set_ry( c );			// Save incremented y
			if( !c ) set_rampy( p + 1 );	// increment rampy if y rolled to zero.
			return(( (dword)p << 16 ) | (dword)y );
		}
		dword dec_rampy_ry( void ) {
			word y = get_ry() - 1;
			byte p = get_rampy();
			set_ry( y );			// Save decremented y
			if( !y ) set_rampy( p - 1 );	// decrement rampy if y rolled to zero.
			return(( (dword)p << 16 ) | (dword)y );
		}
		//
		//	"X"
		//
		dword get_rampx_rx( void ) {
			return(( (dword)get_rampx() << 16 ) | (dword)get_rx());
		}
		dword inc_rampx_rx( void ) {
			word x = get_rx();
			byte p = get_rampx();
			word c = x + 1;
			set_rx( c );			// Save incremented x
			if( !c ) set_rampx( p + 1 );	// increment rampx if x rolled to zero.
			return(( (dword)p << 16 ) | (dword)x );
		}
		dword dec_rampx_rx( void ) {
			word x = get_rx() - 1;
			byte p = get_rampx();
			set_rx( x );			// Save decremented x
			if( !x ) set_rampx( p - 1 );	// decrement rampx if x rolled to zero.
			return(( (dword)p << 16 ) | (dword)x );
		}
		//
		//	"D"
		//
		dword get_rampd_const( word v ) {
			return(( (dword)get_rampd() << 16 ) | (dword)v );
		}


		//
		//	Internal state access routines
		//	==============================
		//
		inline AVR_Type mcu_type( void ) { return( _cpu ); }
		inline byte get_pas_bits( void ) { return( _pas_bits ); }
		inline byte get_pas_bytes( void ) { return( _pas_bytes ); }


		//
		//	Class CPU API Routines.
		//	=======================
		//
		
		//
		//	Reset CPU to initial condition ready for first
		//	instruction execution.
		//
		virtual void reset( void );
{BS}	
		void AVR_CPU::reset( void ) {	
			//
			//	Clear any pending interrupts.
			//
			_irqs->reset();

			//
			//	Status register cleared; global interrupts
			//	disabled.
			//
			*_sr = 0;

			//
			//	Clearing the RAM* and EIND registers
			//
			*_eind = 0;
			*_ram_z = 0;
			*_ram_y = 0;
			*_ram_x = 0;
			*_ram_d = 0;
			
			//
			//	Stack pointer set to the last byte of memory.
			//
			set_SP( _data->capacity()-1 );
			
			//
			//	Program Counter set start of flash memory.
			//
			_pc = 0x0000;
		}
{B}
		//
		//	Execute a single instruction, move PC forward, accepts
		//	interrupts etc as necessary.
		//
		virtual void step( void );
{BS}
		void AVR_CPU::step( void ) {
			Instruction	*inst;
			word		opcode,
					ticks;
			
			//
			//	Step One:	If the _skip_next flag is set
			//			then identify the target instruction
			//			and move over it.
			//
			//			During this period there can be no
			//			interrupts which is why it is the first
			//			action in the instruction handling code.
			//
			if( _skip_next ) {
				_skip_next = false;
				inst = find_instruction( peek_ahead( 0 ));
				ticks = inst->size();
				set_pc( pc_rel( ticks ));
				//
				//	The combination of these clock ticks and those
				//	used by any instruction which sets the _skip_next
				//	flag gives the correct overall clock count.
				//
				_clock->tick( ticks );
			}
			
			//
			//	Step Two:	Interrupts enabled?  If there are
			//			then redirect actions to the IRQ Vector.
			//
			if( get_I()) {
				byte	irq;
				
				//
				//	Look for a pending interrupt..
				//
				if( _irqs->find( &irq )) {
					//
					//	We have an interrupt pending, so we need
					//	to do a couple of things:
					//
					//	1/ Reset the I flag (to stop nested interrupts)
					//	2/ Clear the selected flag (as we are handling it)
					//	3/ Stack the program counter and set it to the
					//	   right vector.
					//
					//	We set the PC to the address of the interrupt 'vector',
					//	though this is not a vector (in my opinion) as we do not
					//	load an address from here, we simply start executing
					//	instructions at this point .. so ... At each IRQ target
					//	address are two words (before the next IRQ target address)
					//	which is enough space for an absolute jump or two single
					//	word instructions.
					//
					set_I( false );
					_irqs->clear( irq );
					//
					//	The following is, honestly, an educated guess;
					//
					//	The above actions take the following durations:
					//
					//		Clear I			1 cycle
					//		Clear IRQ		1 cycle
					//		Stack PC		_pas_bytes cycles
					//		Load PC			1 cycle
					//	
					//	The AVR Documentation says the *minimum* time is 4 cycles,
					//	which would be right for the very smallest AVR MCUs (those
					//	with 8 bit program counters?)
					//
					_clock->tick( push_pc( (dword)irq << 1 ) + 4 );
				}
			}
		
			//
			//	Step Three:	Obtain the opcode word at the
			//			current PC value, identify the
			//			associated instruction and then
			//			execute it.
			//
			opcode = next_opcode();
			inst = find_instruction( opcode );
			if(( ticks = inst->execute( opcode, this ))) {
				_clock->tick( ticks );
			}
			else {
				_error->raise( Unsupported_Instruction, opcode );
			}
		}
{B}
		//
		//	Disassemble the instruction at location PC+offset.
		//
		//	Returns number of opcodes used by the disassembly.
		//
		virtual word disassemble( word offset, char *buffer, int max );
{BS}
		word AVR_CPU::disassemble( word offset, char *buffer, int max ) {
			word		opcode = peek_ahead( 0 );
			Instruction	*inst = find_instruction( opcode );
			return( inst->disassemble( opcode, this, buffer, max ));
		}
{B}
};
{B}


{BH}
//
//	Define a virtual class to be used to handle
//	the methods that implement an instruction.
//
class Instruction {
	protected:
{BC}
		The following definitions are made available to the implementation file
		to simplify the definition of the individual instructions actions.
{B}
		//
		//	Sign extension routine.
		//
		template<class t, word n> static inline t sign_extend( t value ) {
			const t sign_bit = ((t)1)<<(n-1);
			const t sign_fill = ~((sign_bit<<1)-1);
			if( value & sign_bit ) value |= sign_fill;
			return( value );
		}
 

		//
		//	4 bit oriented.
		//
		static inline byte nibble( byte v ) {
			return( v & 0x0F );
		}
{BC}
		Half carry generated if the bottom nibbles added together
		exceed the capacity of a single decimal digit (10 or above).

		Used by code performing BCD maths to correct answers after
		addition.  Is this still used anywhere?
{B}
		static inline bool half( byte a, byte b ) {
			return(( nibble( a ) + nibble( b )) > 9 );
		}
{BC}
		Borrow is generated when the bottom nibble of a is smaller
		than the bottom nibble of b.  In a subtraction this would
		cause a "borrowed" bit from the higher nibble to be carried
		down.
{B}
		static inline bool borrow( byte a, byte b ) {
			return( nibble( a ) < nibble( b ));
		}

		//
		//	8 bit oriented
		//
		static inline bool odd( byte v ) {
			return( v & 0x01 );
		}
		static inline bool sign( byte v ) {
			return( v & 0x80 );
		}
{BC}
		Return indication of signed Overflow if b were added to a
		resulting in c.
{B}
		static inline bool overflow( byte a, byte b, byte c ) {
			return(( sign( a ) == sign( b ))&&( sign( a ) != sign( c )));
		}
{BC}
		Return indication of signed Underflow if b were subtracted
		from a resulting in c.  This is, in effect, the inverse of
		signed overflow.
{B}
		static inline bool underflow( byte a, byte b, byte c ) {
			return( !overflow( a, b, c ));
		}

		static inline bool carry( word v ) {
			return( v & 0x0100 );
		}

		static inline byte negate( byte v ) { return(( ~v ) + 1 ); }

		//
		//	16 bit oriented.
		//
		static inline bool signw( word v ) {
			return( v & 0x8000 );
		}
		static inline byte lsb( word v ) {
			return( (byte)v );
		}
		static inline byte msb( word v ) {
			return( v >> 8 );
		}
		static inline word combine( byte h, byte l ) {
			return(( (word)h << 8 ) | (word)l );
		}
		static word negatew( word v ) { return(( ~v ) + 1 ); }

		//
		//	32 bit oriented.
		//
		static inline word msw( dword v ) {
			return( v >> 16);
		}
		static inline dword combinew( word h, word l ) {
			return(( (dword)h << 16 ) | (dword)l );
		}

		//
		//	Provide a set of routines for breaking down op codes
		//	into their component parts.
		//
		//	Bit assignments: 
		//
		//	rrrrr	= Source register (R0-R31)
		//	ddddd	= Destination register (R0-R31)
		//
		//		____ __r_ ____ rrrr
		//		____ ___d dddd ____
		//
		static inline word arg_r0_r31( word op ) { return(( op & 0x000F )|(( op >> 5 ) & 0x0010 )); }
		static inline word arg_d0_d31( word op ) { return(( op >> 4 ) & 0x001F ); }

		//
		//	rrrr	= Source register (R16–R31)
		//	dddd	= Destination register (R16–R31)
		//
		//		____ ____ ____ rrrr
		//		____ ____ dddd ____
		//
		static inline word arg_r16_r31( word op ) { return(( op & 0x000F ) + 16 ); }
		static inline word arg_d16_d31( word op ) { return((( op >> 4 ) & 0x000F ) + 16 ); }
		//
		//		____ ____ ____ _rrr
		//		____ ____ _ddd ____
		//
		//	rrr	= Source register (R16–R23)
		//	ddd	= Destination register (R16–R23)
		//
		static inline word arg_r16_r23( word op ) { return(( op & 0x0007 ) + 16 ); }
		static inline word arg_d16_d23( word op ) { return((( op >> 4 ) & 0x0007 ) + 16 ); }

		//
		//	RRRR	= Source register pair (R1:R0–R31:R30)
		//	DDDD	= Destination register pair (R1:R0–R31:R30)
		//
		//		____ ____ DDDD ____
		//		____ ____ ____ RRRR
		//
		//	Routines below return even numbers 0 through 30 (16 distinct values)
		//
		static inline word arg_r1r0_r31r30( word op ) { return(( op & 0x000F ) << 1 ); }
		static inline word arg_d1d0_d31d30( word op ) { return(( op >> 3 ) & 0x001E ); }

		//
		//	dd	= Register pair W, X, Y or Z (R25:R24, R27:R26, R29:R28, R31:R30)
		//
		//		____ ____ __dd ____
		//
		//		Routine below returns even numbers 24 through 30 (4 distinct values)
		//
		static inline word arg_d24d25_d30d31( word op ) { return((( op >> 3 ) & 0x0006 ) + 24 ); }
		static inline char arg_WXYZ( word op ) { return( 'W' + (( op >> 4 ) & 0x0003 )); }

		//
		//	aaaaaa	= I/O space address
		//	aaaaa	= I/O space address (first 32 only)
		//
		//		____ _aa_ ____ aaaa
		//		____ ____ aaaa a___
		//
		static inline word arg_a0_a63( word op ) { return(( op & 0x00F )|(( op >> 5 ) & 0x0030 )); }
		static inline word arg_a0_a31( word op ) { return(( op >> 3 ) & 0x001F ); }

		//
		//	bbb	= Bit number (0–7)
		//	sss	= Flag in SREG
		//
		//		____ ____ ____ _bbb
		//		____ ____ _sss ____
		//
		//	Also provide flag index back to letter routine.
		//
		static inline word arg_bit( word op ) { return( op & 0x0007 ); }
		static inline word arg_bit_mask( word op ) { return((word)1 << ( op & 0x0007 )); }
		static inline word arg_flag( word op ) { return(( op >> 4 ) & 0x0007 ); }
		static inline word arg_flag_mask( word op ) { return((word)1 << (( op >> 4 ) & 0x0007 )); }
		static inline char disp_flag( word flag ) {
			static const char flags[ 8 ] = { 'C', 'Z', 'N', 'V', 'S', 'H', 'T', 'I' };
			if( flag > 7 ) return( '?' );
			return( flags[ flag ]);
		}

		//
		//	kkkk		= 4-bit unsigned constant (DES opcode)
		//	KKKKKK		= 6-bit unsigned constant (adiw/sbiw word constant)
		//	kkkkkk		= 6-bit unsigned constant (YZ offset)
		//	KKKKKKKK	= 8-bit (un)signed constant (sign not meaningful in this context)
		//	kkkkkkkkkkkk	= 12 bit signed constant (relative calls/jumps)
		//
		//		____ ____ kkkk ____	4
		//		____ ____ KK__ KKKK	6_w	(adiw/sbiw)
		//		__k_ kk__ ____ _kkk	6_o	(YZ offset)
		//		____ _kkk ____ kkkk	7_rc	(See note)
		//		____ KKKK ____ KKKK	8
		//		____ kkkk kkkk kkkk	12
		//
		//	note:
		//		This addressing mode specific to AVRtiny/AVRrc MCUs,
		//		resulting in an 8 bit address range of 0x40 to 0xbf.
		//
		//		ADDR[7:0] = (~INST[8], INST[8], INST[10], INST[9], INST[3], INST[2], INST[1], INST[0])
		//
		static word arg_imm4( word op ) { return(( op >> 4 ) & 0x000F ); }
		static word arg_imm6_w( word op ) { return(( op & 0x000F )|(( op >> 2 ) & 0x0030 )); }
		static word arg_imm6_o( word op ) { return(( op & 0x0007 )|(( op >> 7 ) & 0x0018 )|(( op >> 8 ) & 0x0020 )); }
		static word arg_imm7_rc( word op ) { return(( op & 0x000F )|(( op >> 5 ) & 0x0030 )|(( op & 0x0100 )?0x0040:0x0080)); }
		static word arg_imm8( word op ) { return(( op & 0x000F )|(( op >> 4 ) & 0x00F0 )); }

		//
		//	jjjjjj +16	= 6-bit and 16-bit unsigned constant (absolute PC)
		//	jjjjjjj		= 7-bit signed constant (relative branching)
		//	jjjjjjjjjjjj	= 12-bit signed constant (longer relative PC)
		//	
		//		____ ___j jjjj ___j	6 then 16 following.
		//		____ __jj jjjj j___	7
		//		____ jjjj jjjj jjjj	12
		//
		static dword arg_absolute( word op, word arg ) { return( combinew((( op & 0x0001 ) | (( op >> 3 ) & 0x003E )), arg )); }
		static dword arg_branch( word op ) { return( sign_extend<dword,7>(( op >> 3 ) & 0x7F )); }
		static dword arg_relative( word op ) { return( sign_extend<dword,12>( op & 0x0FFF )); }

		//
		//	Routine returns number of bits set in a byte value.  Rather than
		//	a 256 element table, we will use a 16 element table, twice.
		//
		static byte count_ones( byte value ) {
			static byte counted[ 16 ] = {	0, 1, 1, 2,	// 0000 0001 0010 0011
							1, 2, 2, 3,	// 0100 0101 0110 0111
							1, 2, 2, 3,	// 1000 1001 1010 1011
							2, 3, 3, 4	// 1100 1101 1110 1111
			};
			return( counted[ value >> 4 ] + counted[ value & 0xF ]);
		}
	public:
		//
		//	Execute an instruction against an AVR state.
		//
		//	Return the number of CPU clock cycles taken to
		//	execute the instruction.  If ZERO is returned
		//	the instruction is not valid on this CPU.
		//
		virtual word execute( word opcode, AVR_CPU *state ) = 0;
		//
		//	Return the number of program words required to
		//	hold the instruction with the supplied opcode.
		//
		//	The default routine returns 1, the most common answer.
		//
		virtual word size( void ) { return( 1 ); }
		//
		//	Fill a buffer with the mnemonic of the instruction.
		//
		//	Return number of program words required to fully
		//	disassemble the instruction.
		//
		virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) = 0;
};


#endif

//
//	EOF
//
{B}

The Decode Implementation File
==============================

The start of the decoding details:

{BS}
//
//	Define the type which will hold a node of the decoder.
//
typedef struct {
	word		mask,		// Which bit do we test (no word index required).
			jump;		// How many to jump if bit is 1.
	Instruction	*data;		// The data structure to return address of.
} decoder_entry;
{B}


At the end of the file we define the lookup function itself.

{BE}
//
//	The lookup function.
//
Instruction *find_instruction( word opcode ) {
	decoder_entry	*ptr;
	word		test;

	ptr = decode_table;
	while(( test = ptr->mask )) ptr += ( opcode & test )? ptr->jump: 1;
	return( ptr->data );
}

//
//	EOF
//
{B}

Define the STACK(x) macro to assist with adjusting the clock timing
data.  The macro is defined to adjust the documented timing data leaving
the base number of clock cycles for the instruction.  Subsequent pushing
or popping the program counter to/from the stack will bring the clock
count to the correct value.  These clock timings will be specified as
(for example) 'STACK( 4 )'.

The push and pop routines return the missing  'additional' clock count of
0, 1 or 2 as required by the size of the pc being emulated (the number of
bytes pushed to or popped from the stack).

	{ #define STACK(n) ((n)-1) }

Finally, define a C character string that contains the 'lead-in'
characters for hexidecimal constant values (when displayed by the
disassembly routines).  I anticipate this will be either "0x" or "$".

	{ #define HEX "0x" }


AVR Instruction Table
=====================

Define the specific details that the decoder encoder needs to know:

	{Z 16 }
	{W 1 }
	{S static }
	{T decoder_entry }
	{N decode_table }

The lookup table generated will point to an instance of class Instruction which
contains methods that enact the various aspects of the identified instruction.

The individual instruction pointers are processed according to the following
'F' record meaning that an instruction 'adc' will be inserted into the lookup
table as '&( adc_inst )'.

	{F &( %_inst )}

Define the 'illegal' instruction implementation.

	{E illegal }
	
{BS}
static class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	Called when any decoded opcode does not uniquely identify a
		//	single specific instruction.
		//
		if( state->raise( Illegal_Instruction, state->get_pc()-1, opcode )) return( 0 );
		//
		//	Action here will depend on the CPU being
		//	simulated.
		//
		//	At present nothing is being done on any CPU.
		//
		switch( state->mcu_type()) {
			case AVR_MCU: {
				break;
			}
			case AVRe_MCU: {
				break;
			}
			case AVRet_MCU: {
				break;
			}
			case AVRxm_MCU: {
				break;
			}
			case AVRxt_MCU: {
				break;
			}
			case AVRrc_MCU: {
				break;
			}
			default: {
				//
				//	Default is to ignore the illegal instruction
				//	and continue program execution.
				//
				break;
			}
		}
		//
		//	All illegal instructions, if ignored, take one cycle.
		//
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "illegal " HEX "%04X", opcode );
		return( 1 );
	}
} illegal_inst;
{B}

The remainder of this document captures each of the instructions.  The order of
the instructions encoding and actions is taken from the PDF document referenced
at the start (AVR-Instruction-Set-Manual-DS40002198A).

The section numbers provided with the instruction title reference directly back to
that document.

The details below summarise the arguments which are encoded into the opcodes of
AVR instructions.

	Opcode encoded argument bits: 

		rrrrr	= Source register (R0-R31)
		ddddd	= Destination register (R0-R31)
		
		rrrr	= Source register (R16–R31)
		dddd	= Destination register (R16–R31)
		
		rrr	= Source register (R16–R23)
		ddd	= Destination register (R16–R23)
		
		RRRR	= Source register pair (R1:R0–R31:R30)
		DDDD	= Destination register pair (R1:R0–R31:R30)
		
		dd	= Register pair W, X, Y or Z (R25:R24, R27:R26, R29:R28, R31:R30)
		
		aaaaaa	= I/O space address
		aaaaa	= I/O space address (first 32 only)
		
		bbb	= Bit number (0–7)
		sss	= Flag in SREG (bit number 0-7)
		
		kkkk	= 4-bit unsigned constant (DES opcode)
		kkkkkk	= 6-bit unsigned constant
		KKKKKKKK= 8-bit constant

		jjjjjjj	= 7-bit signed constant (relative branching)


5.1. ADC – Add with Carry
=========================

{I 000111rdddddrrrr adc }	ADC Rd,Rr		Rd = Rd + Rr + C	(ROL Rd when Rd==Rr)

{BS}
//
//	ADC Rd,Rr		Rd = Rd + Rr + C	(ROL Rd when Rd==Rr)
//	
static class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 11rd dddd rrrr
		//
		byte	dr, dv,		// Destination register and value
			rv,		// Argument register value
			bv;		// Byte result
		word	wv;		// Word result
		bool	c, n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode )) + ( state->get_C()? 1: 0 );
		bv = lsb( wv = dv + rv );
		state->set_H( half( dv, rv ));
		state->set_V( v = overflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	dr, rr;
		
		if(( dr = arg_d0_d31( opcode )) == ( rr = arg_r0_r31( opcode ))) {
			snprintf( buffer, max, "rol r%d", (int)dr );
		}
		else {
			snprintf( buffer, max, "adc r%d,r%d", (int)dr, (int)rr );
		}
		return( 1 );
	}
} adc_inst;
{B}


5.2. ADD – Add without Carry
============================

{I 000011rdddddrrrr add }	ADD Rd,Rr		Rd = Rd + Rr		(LSL Rd when Rd==Rr)

{BS}
//
//	ADD Rd,Rr		Rd = Rd + Rr		(LSL Rd when Rd==Rr)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 11rd dddd rrrr
		//
		byte	dr, dv,		// Destination register and value
			rv,		// Argument register value
			bv;		// Byte result
		word	wv;		// Word result
		bool	c, n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode ));
		bv = lsb( wv = dv + rv );
		state->set_H( half( dv, rv ));
		state->set_V( v = overflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	dr, rr;
		
		if(( dr = arg_d0_d31( opcode )) == ( rr = arg_r0_r31( opcode ))) {
			snprintf( buffer, max, "lsl r%d", (int)dr );
		}
		else {
			snprintf( buffer, max, "add r%d,r%d", (int)dr, (int)rr );
		}
		return( 1 );
	}
} add_inst;
{B}


5.3. ADIW – Add Immediate to Word
=================================
	
{I 10010110KKddKKKK adiw }	ADIW Rd,k		Rd+1:Rd += k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)

Note:
	The below 'adiw' (and 'sbiw') instructions can be considered to be
	as (mnemonically) operating against the registers W, X, Y or Z.
	In this case the instructions could be viewed as:

		ADIW	[WXYZ],k
	and
		SBIW	[WXYZ],k
		

{BS}
//
//	ADIW Rd,k		Rd+1:Rd += k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0110 KKdd KKKK
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 2, 2, 0 };
		
		word	clocks,
			dr, dv,
			wv, kk;
		bool	n, v;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dr = arg_d24d25_d30d31( opcode );
		dv = combine( state->read_reg( dr+1 ),  state->read_reg( dr ));
		kk = arg_imm6_w( opcode );
		wv = dv + kk;
		state->set_V( v = ( signw( dv ) != signw( wv )));
		state->set_N( n = signw( wv ));
		state->set_S( n ^ v );
		state->set_C(( signw( dv ))&&( !signw( wv )));
		state->set_Z( wv == 0 );
		state->write_reg( dr, lsb( wv ));
		state->write_reg( dr + 1, msb( wv ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "adiw %c," HEX "%02X", arg_WXYZ( opcode ), (int)arg_imm6_w( opcode ));
		return( 1 );
	}
} adiw_inst;
{B}


5.4 AND – Logical AND
=====================

{I 001000rdddddrrrr and }	AND Rd,Rr		Rd = Rd & Rr

{BS}
//
//	AND Rd,Rr		Rd = Rd & Rr
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0010 00rd dddd rrrr
		//
		word	dr;
		byte	bv;
		bool	n;
		
		bv = state->read_reg( dr = arg_d0_d31( opcode )) & state->read_reg( arg_r0_r31( opcode ));
		state->set_V( false );
		state->set_N( n = sign( bv ));
		state->set_S( n );
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "and r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} and_inst;
{B}


5.5 ANDI – Logical AND with Immediate
=====================================

{I 0111KKKKddddKKKK andi }	ANDI Rd,K		Rd = Rd & K		(And with 8-bit immediate. Alias: CBR Rd,~K)

{BS}
//
//	ANDI Rd,K		Rd = Rd & K		(And with 8-bit immediate. Alias: CBR Rd,~K)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0111 KKKK dddd KKKK
		//
		word	dr;
		byte	bv;
		bool	n;
		
		bv = state->read_reg( dr = arg_d16_d31( opcode )) & arg_imm8( opcode );
		state->set_V( false );
		state->set_N( n = sign( bv ));
		state->set_S( n );
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:	This instruction (ANDI) is aliased as 'Clear bits in Register' (CBR Rd,K).
		The disassembly routine will note this and display the appropriate version
		based on the number of bits set in the constant argument supplied.

		With 4 or less bits set this is assumed to be an ANDI instruction, with 5
		or more bits this is assumed to be a CBR instruction.

		This is an arbitrary distinction.
{B}
		byte	imm8 = arg_imm8( opcode );
	
		if( count_ones( imm8 ) > 4 ) {
			snprintf( buffer, max, "cbr r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)(~imm8));
		}
		else {
			snprintf( buffer, max, "andi r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)imm8);
		}
		return( 1 );
	}
} andi_inst;
{B}


5.6 ASR – Arithmetic Shift Right
================================

{I 1001010ddddd0101 asr }	ASR Rd		Rd = Rd / 2		(Arithmetic right shift)

{BS}
//
//	ASR Rd		Rd = Rd / 2		(Arithmetic right shift)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0101
		//
		word	dr, dv,
			vv;
		bool	n;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		state->set_N( n = sign( dv ));
		vv = ( dv >> 1 ) | ( n? 0x80: 0x00 );
		state->set_V( false );
		state->set_S( n );
		state->set_Z( vv == 0 );
		state->set_C( odd( dv ));
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "asr r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} asr_inst;
{B}


5.7 BCLR – Bit Clear in SREG
============================

{I 100101001sss1000 bclr }	BCLR s		SREG[s] = 0		(0 <= d <= 31, 0 <= b <= 7)

{BS}
//
//	BCLR s		SREG[s] = 0		(0 <= d <= 31, 0 <= b <= 7)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 1sss 1000
		//
		state->set_sr( state->get_sr() & ~arg_flag_mask( opcode ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int f = arg_flag( opcode );
		snprintf( buffer, max, "bclr %d(%c)", f, disp_flag( f ));
		return( 1 );
	}
} bclr_inst;
{B}


5.8 BLD – Bit Load from the T Bit in SREG to a Bit in Register
==============================================================

{I 1111100ddddd0bbb bld }	BLD Rd,b		Rd[b] = T

{BS}
//
//	BLD Rd,b		Rd[b] = T
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 100d dddd 0bbb
		//
		word	dr, dv;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		if( state->get_T()) {
			dv |= arg_bit_mask( opcode );
		}
		else {
			dv &= ~arg_bit_mask( opcode );
		}
		state->write_reg( dr, dv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "bld r%d,%d", arg_d0_d31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} bld_inst;
{B}


5.9 BRBC – Branch if Bit in SREG is Cleared
===========================================

{I 111101jjjjjjjbbb brbc }	BRBC s,k		If SREG(s) == 0 then PC ← PC + k + 1, else PC ← PC + 1

{BS}
//
//	BRBC s,k		If SREG(s) == 0 then PC ← PC + k + 1, else PC ← PC + 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 01jj jjjj jbbb
		//
		if(( state->get_sr() & arg_bit_mask( opcode )) == 0 ) {
			state->set_pc( state->pc_rel( arg_branch( opcode )));
			return( 2 );
		}
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		static const char *test[ 8 ] = { "cc", "ne", "pl", "vc", "ge", "hc", "tc", "id" };
		snprintf( buffer, max, "br%s %d", test[ arg_bit( opcode )], (int)arg_branch( opcode ));
		return( 1 );
	}
} brbc_inst;
{B}


5.10 BRBS – Branch if Bit in SREG is Set
========================================

{I 111100jjjjjjjbbb brbs }	BRBS s,k		If SREG(s) == 1 then PC ← PC + k + 1, else PC ← PC + 1

{BS}
//
//	BRBS s,k		If SREG(s) == 1 then PC ← PC + k + 1, else PC ← PC + 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 01jj jjjj jbbb
		//
		if(( state->get_sr() & arg_bit_mask( opcode )) != 0 ) {
			state->set_pc( state->pc_rel( arg_branch( opcode )));
			return( 2 );
		}
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		static const char *test[ 8 ] = { "cs", "eq", "mi", "vs", "lt", "hs", "ts", "ie" };
		snprintf( buffer, max, "br%s %d", test[ arg_bit( opcode )], (int)arg_branch( opcode ));
		return( 1 );
	}
} brbs_inst;
{B}


5.11 BRCC – Branch if Carry Cleared
===================================

	See BRBC 0,j


5.12 BRCS – Branch if Carry Set
===============================

	See BRBS 0,j


5.13 BREAK – Break
==================

{I 1001010110011000 break }	BREAK

{BS}
//
//	BREAK						(Stop CPU, enter debug mode)
//	
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 1001 1000
		//
		static byte ticks[ AVR_Types ] = { 0, 1, 1, 1, 1, 1 };
		
		word	clocks;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "break" );
		return( 1 );
	}
} break_inst;
{B}


5.14 BREQ – Branch if Equal
===========================

	See BRBS 1,j


5.15 BRGE – Branch if Greater or Equal (Signed)
===============================================

	See BRBC 4,j


5.16 BRHC – Branch if Half Carry Flag is Cleared
================================================

	See BRBC 5,j


5.17 BRHS – Branch if Half Carry Flag is Set
============================================

	See BRBS 5,j


5.18 BRID – Branch if Global Interrupt is Disabled
==================================================

	See BRBC 7,j


5.19 BRIE – Branch if Global Interrupt is Enabled
=================================================

	See BRBS 7,j


5.20 BRLO – Branch if Lower (Unsigned)
======================================

	BRLO is an alias for BRCS: BRBS 1,j


5.21 BRLT – Branch if Less Than (Signed)
========================================

	See BRBS 4,j


5.22 BRMI – Branch if Minus
===========================

	See BRBS 2,j

	
5.23 BRNE – Branch if Not Equal
===============================

	See BRBC 1,j


5.24 BRPL – Branch if Plus
==========================

	See BRBC 2,j


5.25 BRSH – Branch if Same or Higher (Unsigned)
===============================================

	See BRBC 0,j


5.26 BRTC – Branch if the T Bit is Cleared
==========================================

	See BRBC 6,j


5.27 BRTS – Branch if the T Bit is Set
======================================

	See BRBS 6,j


5.28 BRVC – Branch if Overflow Cleared
======================================

	See BRBC 3,j


5.29 BRVS – Branch if Overflow Set
==================================

	See BRBS 3,j


5.30 BSET – Bit Set in SREG
===========================

{I 100101000sss1000 bset }	BSET s			SREG[s] = 1

{BS}
//
//	BSET s			SREG[s] = 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 0sss 1000
		//
		state->set_sr( state->get_sr() | arg_flag_mask( opcode ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int f = arg_flag( opcode );
		snprintf( buffer, max, "bset %d(%c)", f, disp_flag( f ));
		return( 1 );
	}
} bset_inst;
{B}


5.31 BST – Bit Store from Bit in Register to T Bit in SREG
==========================================================

{I 1111101ddddd0bbb bst }	BST Rd,b		T = Rd[b]

{BS}
//
//	BST Rd,b		T = Rd[b]
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 101d dddd 0bbb
		//
		state->set_T(( state->read_reg( arg_d0_d31( opcode )) & arg_bit_mask( opcode )) != 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "bst r%d,%d", arg_d0_d31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} bst_inst;
{B}


5.32 CALL – Long Call to a Subroutine
=====================================

{I 1001010jjjjj111j jjjjjjjjjjjjjjjj call }	CALL j		DS(STACK-) = PC, PC = j

{BS}
//
//	CALL j		DS(STACK-) = PC, PC = j
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010j jjjj 111j
		//	jjjj jjjj jjjj jjjj
		//
		static byte ticks[ AVR_Types ] = { 0, STACK( 4 ), STACK( 4 ), STACK( 3 ), STACK( 3 ), 0 };
	
		word	clocks,
			arg;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		clocks += state->push_pc( arg_absolute( opcode, state->next_opcode()));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:
		Probably should code to modify the output of the hex target address to match
		the value in _pas_bits and _pas_bytes.  For the moment picking the most common
		16-bit call address is a simple and broadly correct assumption.
{B}
		snprintf( buffer, max, "call " HEX "%04X", arg_absolute( opcode, state->peek_ahead( 1 )));
		return( 2 );
	}
	//
	//	Need to override default instruction size for call.
	//
	virtual word size( void ) { return( 2 ); }

} call_inst;
{B}


5.33 CBI – Clear Bit in I/O Register
====================================

{I 10011000aaaaabbb cbi	}	CBI a,b		IO(a)[b] = 0		(Clear bit b in IO register a)

{BS}
//
//	CBI a,b		IO(a)[b] = 0		(Clear bit b in IO register a)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 1000 aaaa abbb
		//
		word	ir;
		byte	iv;
	
		iv = state->read_io( ir = arg_a0_a31( opcode ));
		state->write_io( ir, iv & ~arg_bit_mask( opcode ));
		return( 0 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cbi %d,%d", arg_a0_a31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} cbi_inst;
{B}


5.34 CBR – Clear Bits in Register
=================================

	CBR Rd,K

This is a alias for ANDI Rd,~K


5.35 CLC – Clear Carry Flag
===========================

Note:	The "BCLR" instruction is the core version of the eight "CL?" instructions,
	and therefore these do not require encoding individually.

	"100101001sss1000 BCLR s" where sss is the SREG bit number to clear.

		1001010010001000 clc
		1001010010011000 clz
		1001010010101000 cln
		1001010010111000 clv
		1001010011001000 cls
		1001010011011000 clh
		1001010011101000 clt
		1001010011111000 cli


5.36 CLH – Clear Half Carry Flag
================================

See section 5.7 and 5.35 above.


5.37 CLI – Clear Global Interrupt Enable Bit
============================================

See section 5.7 and 5.35 above.


5.38 CLN – Clear Negative Flag
==============================

See section 5.7 and 5.35 above.


5.39 CLR – Clear Register
=========================

This is an alias for EOR Rd,Rd.  See section 5.54.


5.40 CLS – Clear Sign Flag
==========================

See section 5.7 and 5.35 above.


5.41 CLT – Clear T Bit
======================

See section 5.7 and 5.35 above.


5.42 CLV – Clear Overflow Flag
==============================

See section 5.7 and 5.35 above.


5.43 CLZ – Clear Zero Flag
==========================

See section 5.7 and 5.35 above.


5.44 COM – One’s Complement
===========================

{I 1001010ddddd0000 com }	COM Rd		Rd = ~Rd		(Ones complement)

{BS}
//
//	COM Rd		Rd = ~Rd		(Ones complement)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0000
		//
		byte	dr, vv;
		bool	n;
		
		vv = ~( state->read_reg( dr = arg_d0_d31( opcode )));
		state->set_V( false );
		state->set_N( n = sign( vv ));
		state->set_S( n );
		state->set_C( true );
		state->set_Z( vv == 0 );
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "com r%d", arg_d0_d31( opcode ));
		return( 1 );
	}
} com_inst;
{B}


5.45 CP – Compare
=================

{I 000101rdddddrrrr cp }	CP Rd,Rr		Rd - Rr			(Compare)

{BS}
//
//	CP Rd,Rr		Rd - Rr			(Compare)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 01rd dddd rrrr
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode ));
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cp r%d, r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cp_inst;
{B}


5.46 CPC – Compare with Carry
=============================

{I 000001rdddddrrrr cpc }	CPC Rd,Rr		Rd - Rr - C		(Compare with Carry)

{BS}
//
//	CPC Rd,Rr		Rd - Rr - C		(Compare with Carry)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 01rd dddd rrrr
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode )) + ( state->get_C()? 1: 0 );
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpc r%d, r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cpc_inst;
{B}


5.47 CPI – Compare with Immediate
=================================

{I 0011KKKKddddKKKK cpi }	CPI Rd,K		Rd - K			(Compare with 8-bit immediate)

{BS}
//
//	CPI Rd,K		Rd - K			(Compare with 8-bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0011 KKKK dddd KKKK
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d16_d31( opcode ));
		rv = arg_imm8( opcode );
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpi r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)arg_imm8( opcode ));
		return( 1 );
	}
} cpi_inst;
{B}


5.48 CPSE – Compare Skip if Equal
=================================

{I 000100rdddddrrrr cpse }	CPSE Rd,Rr		Skip next instruction if Rd == Rr

{BS}
//
//	CPSE Rd,Rr		Skip next instruction if Rd == Rr			(Compare with 8-bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 00rd dddd rrrr
		//
{BC}
	Note:
		The instruction definition says that this instruction will
		take 1, 2 or 3 clock cycles to complete.  In reality this
		instruction takes only 1 instruction to execute, and the
		following 1 or 2 cycles are the following instruction being
		read in, decoded (1 cycle) then an optional argument opcode
		being read in (another 1 cycle).  This creates the range of
		cycles counts the "whole instruction" takes.

		This emulation must ignore interrupts while skipping an
		instruction as this causes potential issues with 'remembering'
		if it was skipping or running when an interrupt is taken.

		A benefit of moving the skipping logic to the main loop enables
		the supporting code to be common across all instructions that
		possibly initiate an instruction skip.
{B}
		if( state->read_reg( arg_d0_d31( opcode )) == state->read_reg( arg_r0_r31( opcode ))) state->set_skip_next();
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpse r%d,r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cpse_inst;
{B}


5.49 DEC – Decrement
====================

{I 1001010ddddd1010 dec }	DEC Rd		Rd = Rd - 1

{BS}
//
//	DEC Rd		Rd = Rd - 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 1010
		//
		byte	dr, dv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		bv = lsb( wv = dv - 1 );
		state->set_V( v = underflow( dv, 1, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "dec r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} dec_inst;
{B}


5.50 DES – Data Encryption Standard
===================================

{I 10010100kkkk1011 des }	DES k			Data Encryption Action 'k'

{BS}
//
//	DES k			Data Encryption Action 'k'
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 kkkk 1011
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 0, 1, 0, 0 };
		
		word	clocks;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
{BC}
		This instruction executes the DES encryption/decryption
		algorithm through repeated calls varying the immediate
		argument supplied.  You could consider this to be 16
		individual instructions.

		This simulation does nothing, and all registers remain
		unmodified effectively making the clear and cypher text
		identical.
{B}
		if( state->raise( Not_Implemented, opcode )) return( 0 );
		
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "des %d", (int)arg_imm4( opcode ));
		return( 1 );
	}
} des_inst;
{B}

5.51 EICALL – Extended Indirect Call to Subroutine
==================================================

{I 1001010100011001 eicall }	EICALL		DS(STACK-) = PC, PC = EIND:Z

{BS}
//
//	EICALL		DS(STACK-) = PC, PC = EIND:Z
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 0001 1001
		//
		static byte ticks[ AVR_Types ] = { 0, 0, STACK( 4 ), STACK( 3 ), STACK( 3 ), 0 };
		
		word	clocks;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		clocks += state->push_pc( state->get_eind_rz());
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "eicall" );
		return( 1 );
	}
} eicall_inst;
{B}


5.52 EIJMP – Extended Indirect Jump
===================================

{I 1001010000011001 eijmp }	EIJMP			PC = EIND:Z

{BS}
//
//	EIJMP			PC = EIND:Z
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 0001 1001
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		if( state->get_pas_bits() <= 16 ) return( 0 );
		state->set_pc( state->get_eind_rz());
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "eijmp" );
		return( 1 );
	}
} eijmp_inst;
{B}


5.53 ELPM – Extended Load Program Memory
========================================


Three versions of this mnemonic:

	'elpm'		Retrieves a byte of program flash memory into register r0
			where RAMPZ:Z specifies the *byte oriented* address of the
			data required (the flash is word addressed by the program
			counter).

	'elpm rN,Z'	As above, but places the data obtained into register N.

	'elpm rN,Z+'	As above, but post-increments the whole RAMPZ:Z register by 1.

	
{I 1001010111011000 elpm_r0 }	ELPM			R0 = PS(RAMPZ:Z)

{BS}
//
//	ELPM			R0 = PS(RAMPZ:Z)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 1101 1000
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 3, 3, 3, 0 };
		
		word	clocks,
			data;
		dword	adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->get_rampz_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( 0, (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "elpm" );
		return( 1 );
	}
} elpm_r0_inst;
{B}

{I 1001000ddddd0110 elpm_z }	ELPM Rd,Z		Rd = PS(RAMPZ:Z)

{BS}
//
//	ELPM Rd,Z		Rd = PS(RAMPZ:Z)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0110
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 3, 3, 3, 0 };
		
		word	clocks,
			data;
		dword	adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->get_rampz_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( arg_d0_d31( opcode ), (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "elpm r%d,Z", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} elpm_z_inst;
{B}

{I 1001000ddddd0111 elpm_zp }	ELPM Rd,Z+		Rd = PS(RAMPZ:Z+)

{BS}
//
//	ELPM Rd,Z+		Rd = PS(RAMPZ:Z+)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0111
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 3, 3, 3, 0 };
		
		word	clocks,
			data;
		dword	adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->inc_rampz_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( arg_d0_d31( opcode ), (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "elpm r%d,Z+", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} elpm_zp_inst;
{B}


5.54 EOR – Exclusive OR
=======================

Note: CLR Rd (section 5.39) is an alias for EOR Rd,Rd (both being the same register).

{I 001001rdddddrrrr eor }	EOR Rd,Rr		Rd = Rd ^ Rr

{BS}
//
//	EOR Rd,Rr		Rd = Rd ^ Rr
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0010 01rd dddd rrrr
		//
		word	dr, dv,
			rv,
			vv;
		bool	n;
		
		rv = state->read_reg( arg_r0_r31( opcode ));
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		vv = rv ^ dv;
		state->set_V( false );
		state->set_N( n = sign( vv ));
		state->set_S( n );
		state->set_Z( vv == 0 );
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	d, r;

		if(( d = arg_d0_d31( opcode )) == ( r = arg_r0_r31( opcode ))) {
			snprintf( buffer, max, "clr r%d", (int)d );
		}
		else {
			snprintf( buffer, max, "eor r%d,r%d", (int)d, (int)r );
		}
		return( 1 );
	}
} eor_inst;
{B}


5.55 FMUL – Fractional Multiply Unsigned
========================================

{I 000000110ddd1rrr fmul }	FMUL Rd,Rr		R1:R0 = Rd x Rr		(unsigned (1.15) = unsigned (1.7) x unsigned (1.7))

{BS}
//
//	FMUL Rd,Rr		R1:R0 = Rd x Rr		(unsigned (1.15) = unsigned (1.7) x unsigned (1.7))
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0011 0ddd 1rrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			dv, rv,
			result;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		rv = state->read_reg( arg_r16_r23( opcode ));	// unsigned (1.7)
		dv = state->read_reg( arg_d16_d23( opcode ));	// unsigned (1.7)
		state->set_C( signw( result = dv * rv ));	// unsigned (2.14)
		result <<= 1;					// unsigned (1.15)
		state->set_Z( result == 0 );
		state->write_reg( 0, lsb( result ));		// extended accuracy
		state->write_reg( 1, msb( result ));		// unsigned (1.7)
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	d, r;

		snprintf( buffer, max, "fmul r%d,r%d", (int)arg_d16_d23( opcode ), (int)arg_r16_r23( opcode ));
		return( 1 );
	}
} fmul_inst;
{B}


5.56 FMULS – Fractional Multiply Signed
=======================================

{I 000000111ddd0rrr fmuls }	FMULS Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x signed (1.7))

{BS}
//
//	FMULS Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x signed (1.7))
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0011 1ddd 0rrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			dv, rv,
			result;
		bool	ds, rs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		if(( rs = sign( rv = state->read_reg( arg_r16_r23( opcode ))))) rv = negate( rv );
		if(( ds = sign( dv = state->read_reg( arg_d16_d23( opcode ))))) dv = negate( dv );
		result = dv * rv;
		if( ds ^ rs ) result = negatew( result );
		state->set_C( signw( result ));
		result <<= 1;
		state->set_Z( result == 0 );
		state->write_reg( 0, lsb( result ));
		state->write_reg( 1, msb( result ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	d, r;

		snprintf( buffer, max, "fmuls r%d,r%d", (int)arg_d16_d23( opcode ), (int)arg_r16_r23( opcode ));
		return( 1 );
	}
} fmuls_inst;
{B}


5.57 FMULSU – Fractional Multiply Signed with Unsigned
======================================================

{I 000000111ddd1rrr fmulsu }	FMULSU Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x unsigned (1.7))

{BS}
//
//	FMULSU Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x unsigned (1.7))
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0011 1ddd 0rrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			dv, rv,
			result;
		bool	ds;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		rv = state->read_reg( arg_r16_r23( opcode ));
		if(( ds = sign( dv = state->read_reg( arg_d16_d23( opcode ))))) dv = negate( dv );
		result = dv * rv;
		if( ds ) result = negatew( result );
		state->set_C( signw( result ));
		result <<= 1;
		state->set_Z( result == 0 );
		state->write_reg( 0, lsb( result ));
		state->write_reg( 1, msb( result ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	d, r;

		snprintf( buffer, max, "fmulsu r%d,r%d", (int)arg_d16_d23( opcode ), (int)arg_r16_r23( opcode ));
		return( 1 );
	}
} fmulsu_inst;
{B}


5.58 ICALL – Indirect Call to Subroutine
========================================

{I 1001010100001001 icall }	ICALL Z		DS(STACK-) = PC, PC = Z	(Pushes 2 or 3 bytes)

{BS}
//
//	ICALL Z		DS(STACK-) = PC, PC = Z	(Pushes 2 or 3 bytes)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 0000 1001
		//
		static byte ticks[ AVR_Types ] = { STACK( 3 ), STACK( 3 ), STACK( 3 ), STACK( 2 ), STACK( 2 ), STACK( 3 )};
		
		return( ticks[ state->mcu_type()] + state->push_pc( state->get_rz()));
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "icall" );
		return( 1 );
	}
} icall_inst;
{B}


5.59 IJMP – Indirect Jump
=========================

{I 1001010000001001 ijmp }	IJMP			PC = Z

{BS}
//
//	IJMP			PC = Z
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 0000 1001
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 2, 2, 2 };
		state->set_pc( state->get_rz());
		return( ticks[ state->mcu_type()]);
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ijmp" );
		return( 1 );
	}
} ijmp_inst;
{B}


5.60 IN - Load an I/O Location to Register
==========================================

{I 10110aadddddaaaa in }	IN Rd,a		Rd = IO(a)		(Output register to IO address)

{BS}
//
//	IN Rd,a		Rd = IO(a)		(Output register to IO address)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1011 0aad dddd aaaa
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_io( arg_a0_a63( opcode )));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "in r%d,%d", (int)arg_d0_d31( opcode ), (int)arg_a0_a63( opcode ));
		return( 1 );
	}
} in_inst;
{B}


5.61 INC – Increment
====================

{I 1001010ddddd0011 inc }	INC Rd		Rd = Rd + 1		(Increment Rd)

{BS}
//
//	INC Rd		Rd = Rd + 1		(Increment Rd)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 1010
		//
		byte	dr, dv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		bv = lsb( wv = dv + 1 );
		state->set_V( v = overflow( dv, 1, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "inc r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} inc_inst;
{B}


5.62 JMP – Jump
===============

{I 1001010jjjjj110j jjjjjjjjjjjjjjjj jmp }	JMP j		PC = j

{BS}
//
//	JMP j		PC = j
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010j jjjj 110j
		//	jjjj jjjj jjjj jjjj
		//
		static byte ticks[ AVR_Types ] = { 0, 3, 3, 3, 3, 0 };
	
		word	clocks,
			arg;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		state->set_pc( arg_absolute( opcode, state->next_opcode()));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:
		Probably should code to modify the output of the hex target address to match
		the value in _pas_bits and _pas_bytes.  For the moment picking the most common
		16-bit call address is a simple and broadly correct assumption.
{B}
		snprintf( buffer, max, "jmp " HEX "%04X", arg_absolute( opcode, state->peek_ahead( 1 )));
		return( 2 );
	}
	//
	//	Need to override default instruction size for jmp.
	//
	virtual word size( void ) { return( 2 ); }

} jmp_inst;
{B}


5.63 LAC – Load and Clear
=========================

{I 1001001ddddd0110 lac	 }	LAC Z,Rd		DS(Z) = DS(Z) & ~Rd, Rd = DS(Z)	(Atomic read and clear)

{BS}
//
//	LAC Z,Rd		DS(Z) = DS(Z) & ~Rd, Rd = DS(Z)	(Atomic read and clear)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 001d dddd 0110
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 0, 2, 0, 0 };
	
		word	clocks;
		byte	dr, dv;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		state->write_reg( dr, state->modify_data( state->get_rampz_rz(), dv, 0, 0 ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lac Z,r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} lac_inst;
{B}


5.64 LAS – Load and Set
=======================

{I 1001001ddddd0101 las }	LAS Z,Rd		DS(Z) = DS(Z) | Rd, Rd = DS(Z)	(Atomic read and set)

{BS}
//
//	LAS Z,Rd		DS(Z) = DS(Z) | Rd, Rd = DS(Z)	(Atomic read and set)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 001d dddd 0101
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 0, 2, 0, 0 };
	
		word	clocks;
		byte	dr, dv;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		state->write_reg( dr, state->modify_data( state->get_rampz_rz(), 0, dv, 0 ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "las Z,r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} las_inst;
{B}


5.65 LAT – Load and Toggle
==========================

{I 1001001ddddd0111 lat }	LAT Z,Rd		DS(Z) = DS(Z) ^ Rd, Rd = DS(Z)	(Atomic read and toggle)

{BS}
//
//	LAT Z,Rd		DS(Z) = DS(Z) ^ Rd, Rd = DS(Z)	(Atomic read and toggle)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 001d dddd 0111
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 0, 2, 0, 0 };
	
		word	clocks;
		byte	dr, dv;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		state->write_reg( dr, state->modify_data( state->get_rampz_rz(), 0, 0, dv ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lat Z,r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} lat_inst;
{B}


5.66 LD – Load Indirect from Data Space to Register using X
===========================================================

{I 1001000ddddd1100 ld_x }	LD Rd,X			Rd = DS(X)

{BS}
//
//	LD Rd,X			Rd = DS(X)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1100
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->get_rampx_rx()));
{BC}
		Note:
			The cycle times associated with this instruction
			(and probably many other that access through the
			DS() memory route) have variable cycles counts that
			are effectively determined by the address (ie what
			area of memory you access).  This is especially of
			note if the RAM is external to the MCU.

			For the moment, the answer '2' is mostly right.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,X", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_x_inst;
{B}

{I 1001000ddddd1101 ld_xp }	LD Rd,X+		Rd = DS(X+)

{BS}
//
//	LD Rd,X+		Rd = DS(X+)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1101
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->inc_rampx_rx()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,X+", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_xp_inst;
{B}

{I 1001000ddddd1110 ld_nx }	LD Rd,-X		Rd = DS(-X)

{BS}
//
//	LD Rd,-X		Rd = DS(-X)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1110
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->dec_rampx_rx()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,-X", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_nx_inst;
{B}


5.67 LD (LDD) – Load Indirect from Data Space to Register using Y
=================================================================

Documentation indicates that there are mnemonics for the
instructions 'LD Rd,Y' (and 'LD Rd,Z').  However examining
the binary opcode itself, these instructions should be
recognised as actually being an alias for the instructions
'LDD Rd,Y+0' (and 'LDD Rd,Z+0' below).

Also note that while the above is true, for the AVRrc *only* the
'LDD Rd, Y+0' is implemented as 'LD Rd,Y' (similar for Z version
below).  This distinction, possible to simulate, has not been
done so, yet.

{I 10q0qq0ddddd1qqq ldd_y_q }	LDD RD,Y+q		Rd = DS(Y+q)

{BS}
//
//	LDD RD,Y+q		Rd = DS(Y+q)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	10q0 qq0d dddd 1qqq
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->get_rampy_ry() + arg_imm6_o( opcode )));
{BC}
		Note:
			The cycle times associated with this instruction
			(and probably many others that access through the
			DS() memory route) have variable cycles counts that
			are effectively determined by the address (ie what
			area of memory you access).  This is especially of
			note if the RAM is external to the MCU.

			For the moment, the answer '2' is mostly right.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int	a;

		if(( a = arg_imm6_o( opcode ))) {
			snprintf( buffer, max, "ldd r%d,Y+%d", (int)arg_d0_d31( opcode ), a );
		}
		else {
			snprintf( buffer, max, "ld r%d,Y", (int)arg_d0_d31( opcode ));
		}
		return( 1 );
	}
} ldd_y_q_inst;
{B}

{I 1001000ddddd1001 ld_yp }	LD Rd,Y+		Rd = DS(Y+)

{BS}
//
//	LD Rd,Y+		Rd = DS(Y+)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1001
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->inc_rampy_ry()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,Y+", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_yp_inst;
{B}

{I 1001000ddddd1010 ld_ny }	LD Rd,−Y		Rd = DS(-Y)

{BS}
//
//	LD Rd,−Y		Rd = DS(-Y)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1010
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->dec_rampy_ry()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,-Y", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_ny_inst;
{B}


5.68 LD (LDD) – Load Indirect From Data Space to Register using Z
=================================================================

See note in 5.67 regarding 'LD Rd,Z' as alias for 'LDD Rd,Z+0'.

{I 10q0qq0ddddd0qqq ldd_z_q }	LDD Rd,Z+q		Rd = DS(Z+q)

{BS}
//
//	LDD Rd,Z+q		Rd = DS(Z+q)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	10q0 qq0d dddd 0qqq
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->get_rampz_rz() + arg_imm6_o( opcode )));
{BC}
		Note:
			The cycle times associated with this instruction
			(and probably many other that access through the
			DS() memory route) have variable cycles counts that
			are effectively determined by the address (ie what
			area of memory you access).  This is especially of
			note if the RAM is external to the MCU.

			For the moment, the answer '2' is mostly right.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int	a;

		if(( a = arg_imm6_o( opcode ))) {
			snprintf( buffer, max, "ldd r%d,Z+%d", (int)arg_d0_d31( opcode ), a );
		}
		else {
			snprintf( buffer, max, "ld r%d,Z", (int)arg_d0_d31( opcode ));
		}
		return( 1 );
	}
} ldd_z_q_inst;
{B}

{I 1001000ddddd0001 ld_zp }	LD Rd,Z+		Rd = DS(Z+)

{BS}
//
//	LD Rd,Z+		Rd = DS(Z+)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0001
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->inc_rampz_rz()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,Z+", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_zp_inst;
{B}

{I 1001000ddddd0010 ld_nz }	LD Rd,−Z		Rd = DS(-Z)

{BS}
//
//	LD Rd,−Z		Rd = DS(-Z)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0010
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->dec_rampz_rz()));
{BC}
		Note the timing issues outlined above.
{B}
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ld r%d,-Z", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} ld_nz_inst;
{B}


5.69 LDI – Load Immediate
=========================

{I 1110KKKKddddKKKK ldi }	LDI Rd,K		Rd = K			(Load register with 8 bit immediate)

{BS}
//
//	LDI Rd,K		Rd = K			(Load register with 8 bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1110 KKKK dddd KKKK
		//
		state->write_reg( arg_d16_d31( opcode ), arg_imm8( opcode ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ldi r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)arg_imm8( opcode ));
		return( 1 );
	}
} ldi_inst;
{B}


5.70 LDS – Load Direct from Data Space
======================================

{I 1001000ddddd0000 kkkkkkkkkkkkkkkk lds }	LDS rd,k		Rd = DS(RAMPD:k)	(Data Space Immediate address)

{BS}
//
//	LDS rd,k		Rd = DS(RAMPD:k)	(Data Space Immediate address)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0000
		//	kkkk kkkk kkkk kkkk
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 3, 3, 0 };
	
		word	clocks,
			arg;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		state->write_reg( arg_d0_d31( opcode ), state->read_data( state->get_rampd_const( state->next_opcode())));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lds r%d," HEX "%04X", (int)arg_d0_d31( opcode ), (int)state->next_opcode());
		return( 2 );
	}
	//
	//	Need to override default instruction size for call.
	//
	virtual word size( void ) { return( 2 ); }
} lds_inst;
{B}

5.71 LDS (AVRrc) – Load Direct from Data Space
==============================================

The following AVRtiny instruction overlaps with a number of other
larger AVR MCU instructions:

	'std_z_q'
	'std_y_q'
	'ldd_z_q'
	'ldd_y_q'
	
The instruction detail and implementation below has (for the moment) been
set to be ignored.

{BC}
	{I 10100kkkddddkkkk lds_AVRrc }

	//
	//	LDS rd,k		Rd = DS(k)	(Data Space Immediate address)
	//
	class : public Instruction {
	public:
		virtual word execute( word opcode, AVR_CPU *state ) {
			//
			//	1010 0kkk dddd kkkk
			//
			static byte ticks[ AVR_Types ] = { 0, 0, 0, 0, 0, 2 };
		
			word	clocks,
				arg;
		
			if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
			state->write_reg( arg_d16_d31( opcode ), state->read_data( arg_imm7_rc( opcode )));
			return( clocks );
		}
		virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
			snprintf( buffer, max, "lds r%d," HEX "%02X", (int)arg_d0_d31( opcode ), (int)arg_imm7_rc( opcode ));
			return( 1 );
		}
	} lds_inst;
{B}

5.72 LPM – Load Program Memory
==============================

Three versions of this mnemonic:

	'lpm'		Retrieves a byte of program flash memory into register r0
			where Z specifies the *byte oriented* address of the
			data required (the flash is word addressed by the program
			counter).

	'lpm rN,Z'	As above, but places the data obtained into register N.

	'lpm rN,Z+'	As above, but post-increments the Z register by 1.

{I 1001010111001000 lpm_r0 }	LPM			R0 = PS(Z)

{BS}
//
//	LPM			R0 = PS(Z)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 1100 1000
		//
		static byte ticks[ AVR_Types ] = { 3, 3, 3, 3, 3, 0 };
		
		word	clocks,
			data,
			adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->get_rampz_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( 0, (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lpm" );
		return( 1 );
	}
} lpm_r0_inst;
{B}


{I 1001000ddddd0100 lpm_z }	LPM Rd,Z		Rd = PS(Z)

{BS}
//
//	LPM Rd,Z		Rd = PS(Z)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0100
		//
		static byte ticks[ AVR_Types ] = { 3, 3, 3, 3, 3, 0 };
		
		word	clocks,
			data,
			adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->get_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( arg_d0_d31( opcode ), (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lpm r%d,Z", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} lpm_z_inst;
{B}

{I 1001000ddddd0101 lpm_zp }	LPM Rd,Z+		Rd = PS(Z+)

{BS}
//
//	LPM Rd,Z+		Rd = PS(Z+)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 0101
		//
		static byte ticks[ AVR_Types ] = { 3, 3, 3, 3, 3, 0 };
		
		word	clocks,
			data,
			adrs;

		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		adrs = state->inc_rz();
		data = state->read_flash( adrs >> 1 );
		state->write_reg( arg_d0_d31( opcode ), (( adrs & 1 )? msb( data ): lsb( data )));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lpm r%d,Z+", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} lpm_zp_inst;
{B}


5.73 LSL – Logical Shift Left
=============================

See section 5.2. ADD – Add without Carry.



5.74 LSR – Logical Shift Right
==============================

{I 1001010ddddd0110 lsr }	LSR Rd		Rd = Rd >> 1		(Logical right shift)

{BS}
//
//	LSR Rd		Rd = Rd >> 1		(Logical right shift)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0110
		//
		byte	dr, dv,		// Destination register and value
			bv;		// Byte result
		bool	c;
		
		bv = ( dv = state->read_reg( dr = arg_d0_d31( opcode ))) >> 1;
		state->set_C( c = odd( dv ));
		state->set_N( false );	// n = 0
		state->set_V( c );	// v = n ^ c = 0 ^ c = c
		state->set_S( c );	// s = n ^ v = 0 ^ v = 0 ^ c = c
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "lsr r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} lsr_inst;
{B}



5.75 MOV – Copy Register
========================

{I 001011rdddddrrrr mov }	MOV Rd,Rr		Rd = Rr

{BS}
//
//	MOV Rd,Rr		Rd = Rr
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0010 11rd dddd rrrr
		//
		state->write_reg( arg_d0_d31( opcode ), state->read_reg( arg_r0_r31( opcode )));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "mov r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} mov_inst;
{B}



5.76 MOVW – Copy Register Word
==============================


{I 00000001DDDDRRRR movw }	MOVW Rd+1:Rd,Rr+1:Rr	Rd+1:Rd = Rr+1:Rr	(Move register pair)

{BS}
//
//	MOVW Rd+1:Rd,Rr+1:Rr	Rd+1:Rd = Rr+1:Rr	(Move register pair)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0001 DDDD RRRR
		//
		static byte ticks[ AVR_Types ] = { 0, 1, 1, 1, 1, 0 };
		
		word	clocks,
			dr, rr;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dr = arg_d1d0_d31d30( opcode );
		rr = arg_r1r0_r31r30( opcode );
		state->write_reg( dr, state->read_reg( rr ));
		state->write_reg( dr+1, state->read_reg( rr+1 ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	dr, rr;
		
		dr = arg_d1d0_d31d30( opcode );
		rr = arg_r1r0_r31r30( opcode );
		snprintf( buffer, max, "movw r%d:r%d,r%d:r%d", (int)(dr+1), (int)dr, (int)(rr+1), (int)rr );
		return( 1 );
	}
} movw_inst;
{B}


5.77 MUL – Multiply Unsigned
============================

{I 100111rdddddrrrr mul }	MUL Rd,Rr		R1:R0 = Rr x Rd		(unsigned = unsigned x unsigned)

{BS}
//
//	MUL Rd,Rr		R1:R0 = Rr x Rd		(unsigned = unsigned x unsigned)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 11rd dddd rrrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			result;
		byte	dv, rv;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dv = state->read_reg( arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode ));
		result = dv * rv;
		state->set_C( signw( result ));
		state->set_Z( result == 0 );
		state->write_reg( 1, msb( result ));
		state->write_reg( 0, lsb( result ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "mul r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} mul_inst;
{B}


5.78 MULS – Multiply Signed
===========================

{I 00000010ddddrrrr muls}	MULS Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x signed)

{BS}
//
//	MULS Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x signed)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 11rd dddd rrrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			result;
		byte	dv, rv;
		bool	ds, rs;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		if(( ds = sign( dv = state->read_reg( arg_d0_d31( opcode ))))) dv = negate( dv );
		if(( rs = sign( rv = state->read_reg( arg_r0_r31( opcode ))))) rv = negate( rv );
		result = dv * rv;
		if( ds ^ rs ) result = negatew( result );
		state->set_C( signw( result ));
		state->set_Z( result == 0 );
		state->write_reg( 1, msb( result ));
		state->write_reg( 0, lsb( result ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "muls r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} muls_inst;
{B}


5.79 MULSU – Multiply Signed with Unsigned
==========================================

{I 000000110ddd0rrr mulsu }	MULSU Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x unsigned)

{BS}
//
//	MULSU Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x unsigned)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0011 0ddd 0rrr
		//
		static byte ticks[ AVR_Types ] = { 0, 0, 2, 2, 2, 0 };
		
		word	clocks,
			result;
		byte	dv, rv;
		bool	ds;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		if(( ds = sign( dv = state->read_reg( arg_d16_d23( opcode ))))) dv = negate( dv );
		rv = state->read_reg( arg_r16_r23( opcode ));
		result = dv * rv;
		if( ds ) result = negatew( result );
		state->set_C( signw( result ));
		state->set_Z( result == 0 );
		state->write_reg( 1, msb( result ));
		state->write_reg( 0, lsb( result ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "muls r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} mulsu_inst;
{B}


5.80 NEG – Two’s Complement
===========================

{I 1001010ddddd0001 neg }	NEG Rd		Rd = -Rd		(Twos complement)

{BS}
//
//	NEG Rd		Rd = -Rd		(Twos complement)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0001
		//
		byte	dr, dv,
			bv;
		bool	n, v;
		
		bv = 0 - ( dv = state->read_reg( dr = arg_d0_d31( opcode )));
		state->set_H( borrow( 0, dv ));
		state->set_V( v = ( bv == 0x80 ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( dv != 0 );
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "neg r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} neg_inst;
{B}


5.81 NOP – No Operation
=======================

{I 0000000000000000 nop }	NOP					(No Operation)

{BS}
//
//	NOP					(No Operation)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 0000 0000 0000
		//
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "nop" );
		return( 1 );
	}
} nop_inst;
{B}


5.82 OR – Logical OR
====================

{I 001010rdddddrrrr or }	OR Rd,Rr		Rd = Rd | Rr

{BS}
//
//	OR Rd,Rr		Rd = Rd | Rr
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0010 10rd dddd rrrr
		//
		word	dr;
		byte	bv;
		bool	n;
		
		bv = state->read_reg( dr = arg_d0_d31( opcode )) | state->read_reg( arg_r0_r31( opcode ));
		state->set_V( false );
		state->set_N( n = sign( bv ));
		state->set_S( n );
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "or r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} or_inst;
{B}



5.83 ORI – Logical OR with Immediate
====================================

{I 0110KKKKddddKKKK ori }	ORI Rd,K		Rd = Rd | K		(Or with 8-bit immediate. Also: SBR Rd,K)

{BS}
//
//	ORI Rd,K		Rd = Rd | K		(Or with 8-bit immediate. Also: SBR Rd,K)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0110 KKKK dddd KKKK
		//
		word	dr;
		byte	bv;
		bool	n;
		
		bv = state->read_reg( dr = arg_d16_d31( opcode )) | arg_imm8( opcode );
		state->set_V( false );
		state->set_N( n = sign( bv ));
		state->set_S( n );
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:	This instruction (ORI) is aliased as 'Set bits in Register' (SBR Rd,K).
		The disassembly routine will note this and display one version
		based on the number of bits set in the constant argument supplied.

		With 4 or less bits set this is assumed to be an SBR instruction, with 5
		or more bits this is assumed to be a ORI instruction.

		This is an arbitrary distinction.
{B}
		byte	imm8 = arg_imm8( opcode );
	
		if( count_ones( imm8 ) < 4 ) {
			snprintf( buffer, max, "sbr r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)imm8);
		}
		else {
			snprintf( buffer, max, "ori r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)imm8);
		}
		return( 1 );
	}
} ori_inst;
{B}


5.84 OUT – Store Register to I/O Location
=========================================

{I 10111aadddddaaaa out }	OUT a,Rd		IO(a) = Rd		(Write register to IO address)

{BS}
//
//	OUT a,Rd		IO(a) = Rd		(Write register to IO address)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1011 1aad dddd aaaa
		//
		state->write_io( arg_a0_a63( opcode ), state->read_reg( arg_d0_d31( opcode )));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "out %d,r%d", (int)arg_a0_a63( opcode ), (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} out_inst;
{B}


5.85 POP – Pop Register from Stack
==================================

{I 1001000ddddd1111 pop }	POP Rd		Rd = DS(+STACK)

{BS}
//
//	POP Rd		Rd = DS(+STACK)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 000d dddd 1111
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 2, 2, 3 };
		
		state->push_byte( state->read_reg( arg_d0_d31( opcode )));
		return( ticks[ state->mcu_type()]);
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "pop r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} pop_inst;
{B}


5.86 PUSH – Push Register on Stack
==================================

{I 1001001ddddd1111 push }	PUSH Rd		DS(STACK-) = Rd

{BS}
//
//	PUSH Rd		DS(STACK-) = Rd
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 001d dddd 1111
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 1, 1, 1 };
		
		state->write_reg( arg_d0_d31( opcode ), state->pop_byte());
		return( ticks[ state->mcu_type()]);
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "push r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} push_inst;
{B}


5.87 RCALL – Relative Call to Subroutine
========================================

{I 1101jjjjjjjjjjjj rcall }	RCALL j		DS(STACK-) = PC, PC = PC + j (Relative call, j is signed 12 bit immediate)

{BS}
//
//	RCALL j		DS(STACK-) = PC, PC = PC + j (Relative call, j is signed 12 bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1101 jjjj jjjj jjjj
		//
		static byte ticks[ AVR_Types ] = { STACK( 3 ), STACK( 3 ), STACK( 3 ), STACK( 2 ), STACK( 2 ), STACK( 3 )};

		return( ticks[ state->mcu_type()] + state->push_pc( state->pc_rel( arg_relative( opcode ))));
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "rcall %d", (int)arg_relative( opcode ));
		return( 1 );
	}
} rcall_inst;
{B}


5.88 RET – Return from Subroutine
=================================

{I 1001010100001000 ret }	RET			PC = DS(+STACK)		(Pops 2 or 3 bytes as appropriate to AVR architecture)

{BS}
//
//	RET			PC = DS(+STACK)		(Pops 2 or 3 bytes as appropriate to AVR architecture)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 0000 1000
		//
		static byte ticks[ AVR_Types ] = { STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 6 )};

		return( ticks[ state->mcu_type()] + state->pop_pc());
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "ret" );
		return( 1 );
	}
} ret_inst;
{B}


5.89 RETI – Return from Interrupt
=================================

{I 1001010100011000 reti }	RETI			PC = DS(+STACK),I = 1

{BS}
//
//	RETI			PC = DS(+STACK),I = 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 0000 1000
		//
		static byte ticks[ AVR_Types ] = { STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 4 ), STACK( 6 )};

		state->set_I( true );
		return( ticks[ state->mcu_type()] + state->pop_pc());
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "reti" );
		return( 1 );
	}
} reti_inst;
{B}


5.90 RJMP – Relative Jump
=========================

{I 1100jjjjjjjjjjjj rjmp }	RJMP j		PC = PC + j		(Relative jump, j is signed 12 bit immediate)

{BS}
//
//	RJMP j		PC = PC + j		(Relative jump, j is signed 12 bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1101 jjjj jjjj jjjj
		//
		state->set_pc( state->pc_rel( arg_relative( opcode )));
		return( 2 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "rjmp %d", (int)arg_relative( opcode ));
		return( 1 );
	}
} rjmp_inst;
{B}



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{I 000010rdddddrrrr sbc			} SBC Rd,Rr		Rd = Rd - Rr - C
	static word op_sbc( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000110rdddddrrrr sub			} SUB Rd,Rr		Rd = Rd - Rr
	static word op_sub( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 0100KKKKddddKKKK sbci		} SBCI Rd,K		Rd = Rd - K - C		(Subtract 8-bit immediate and Carry)
	static word op_sbci( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 0101KKKKddddKKKK subi		} SUBI Rd,K		Rd = Rd - K		(Subtract 8-bit immediate)
	static word op_subi( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0000 kkkkkkkkkkkkkkkk sts } STS k,rd		DS(RAMPD:k) = Rd
	static word op_sts( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0100 xch			} XCH Z,Rd 		DS(Z) <-> Rd
	static word op_xch( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1100 st_x		} ST X,Rd		DS(X) = Rd
	static word op_st_x( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1101 st_xp		} ST X+,Rd		DS(X+) = Rd
	static word op_st_xp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1110 st_nx		} ST -X,Rd		DS(-X) = Rd
	static word op_st_nx( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


Note:
	Documentation indicates that there are mnemonics for the
	instructions 'ST Y,Rd' and 'ST Z,Rd'.  However examining
	the binary opcode itself, these instructions should be
	recognised as actually being an alias for the instructions
	'ST Y+0,Rd' and 'ST Z+0,Rd'

{I 10q0qq1rrrrr1qqq std_y_q		} STD Y+q,Rd		DS(Y+q) = Rd			(See Note)
	static word op_std_y_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1001 st_yp		} ST Y+,Rd		DS(Y+) = Rd
	static word op_st_yp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1010 st_ny		} ST −Y,Rd		DS(-Y) = Rd
	static word op_st_ny( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10q0qq1rrrrr0qqq std_z_q		} STD Z+q,Rd		DS(Z+q) = Rd			(See Note)
	static word op_std_z_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0001 st_zp		} ST Z+,Rd		DS(Z+) = Rd
	static word op_st_zp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0010 st_nz		} ST −Z,Rd		DS(-Z) = Rd
	static word op_st_nz( word opcode, AVR_CPU *state ) {
		return( 0 );
	}



Note:	The "BSET" instruction is a core version of the eight "SE?" instructions,
	and therefore these do not require encoding individually.

	"100101000sss1000 BCLR s" where sss is the SREG bit number to set.

		1001010000001000 sec
		1001010000011000 sez
		1001010000101000 sen
		1001010000111000 sev
		1001010001001000 ses
		1001010001011000 seh
		1001010001101000 set
		1001010001111000 sei

{I 1001010110001000 sleep		} SLEEP						(Put CPU into sleep mode)
	static word op_sleep( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010110101000 wdr			} WDR						(Restart Watch Dog Timer)
	static word op_wdr( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010111101000 spm			} SPM						(See section 116 in "AVR Instruction Set Manual")
{I 1001010111111000 spm			} SPM Z+ 					(See section 117 in "AVR Instruction Set Manual")
	static word op_spm( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


{I 1001010ddddd0010 swap		} SWAP Rd		Rd[0:3] <-> Rd[7:4]	(Swap nibbles in Rd)
	static word op_swap( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010ddddd0111 ror			} ROR Rd		C -> Rd -> C		(Rotate right Rd through Carry)
	static word op_ror( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10010111kkddkkkk sbiw		} SBIW Rp,k		Rd+1:Rd -= k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)
	static word op_sbiw( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011001aaaaabbb sbic		} SBIC a,b		If IO(a)[b] == 0 skip	(Skip next instruction if bit b in IO register a is clear)
	static word op_sbic( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011010aaaaabbb sbi			} SBI a,b		IO(a)[b] = 1		(Set bit b in IO register a)
	static word op_sbi( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011011aaaaabbb sbis		} SBIS a,b		If IO(a)[b] == 1 skip	(Skip next instruction if bit b in IO register a is set)
	static word op_sbis( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1111110ddddd0bbb sbrc		} SBRC Rd,b		Skip next if Rd[b] == 0
	static word op_sbrc( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1111111ddddd0bbb sbrs		} SBRS Rd,b		Skip next if Rd[b] == 1
	static word op_sbrs( word opcode, AVR_CPU *state ) {
		return( 0 );
	

{I 1001010110111000 reserved		} 			Reserved 
{I 10010101001x1000 reserved		} 			Reserved
{I 1001010101xx1000 reserved		} 			Reserved
{I 1001010ddddd0100 reserved		} 			Reserved
{I 11111xxddddd1bbb reserved		} 			Reserved
	static word op_reserved( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


End of Instruction data.
========================
