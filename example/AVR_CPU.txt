

	#####
	#     #     #    #    #  #    #  #         ##     #####  ######
	#           #    ##  ##  #    #  #        #  #      #    #
	 #####      #    # ## #  #    #  #       #    #     #    #####
	      #     #    #    #  #    #  #       ######     #    #
	#     #     #    #    #  #    #  #       #    #     #    #
	 #####      #    #    #   ####   ######  #    #     #    ######

			   #    #     # ######
			  # #   #     # #     #
			 #   #  #     # #     #
			#     # #     # ######
			#######  #   #  #   #
			#     #   # #   #    #
			#     #    #    #     #

An implementation of an AVR Microcontroller CPU, encoded using the
'encode_decoder' pre-processor for which source code be located at
"https://github.com/GreyLimit/encode_decoder"


Set output language to C++ for the encode_decoder processor.  This needs
to precede any other processor records to ensure consistent output.
{L C++}

AVR Instruction Encoding
========================

This data has been distilled from these sources:

	https://en.wikipedia.org/wiki/Atmel_AVR_instruction_set
	
	http://ww1.microchip.com/downloads/en/devicedoc/atmel-0856-avr-instruction-set-manual.pdf
	https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-Instruction-Set-Manual-DS40002198A.pdf

In explanation:

	The Wiki page supplied an initial consolidated view of instructions
	encoding, and potentially offered a mechanism to allow analysis of
	the encoding system (which led to the development of the encode_decoder
	pre-processor program).
	
	The Microchip Atmel documents, being the final authority on the subject,
	provided the specific information on the instructions and their operation.

	While the source of the technical details is authoritative, the accuracy
	of this implementation has to be subject to the acknowledgment that I have
	done this without any external confirmation process (so far).


The Decode Implementation File
==============================

Start the implementation file for the
decoder.

{BS}
//
//	AVR_CPU.cpp
//	-----------
//
//	Containing only the decoder table generated
//	by 'encode_decoder' from the data file
//	'AVR_CPU.txt'.
//

//
//	Include standard stuff.
//
#include <stdlib.h>

//
//	Include the definitions required for the
//	table to compile.
//
#include "AVR_CPU.h"
{BF}

The Decode Definitions File
===========================

Set out in the header file the interface to the
decoder.  This is the definition of the AVR CPU
state record.

{BH}
//
//	AVR_CPU.h
//	---------
//

#ifndef _AVR_DECODER_H_
#define _AVR_DECODER_H_

//
//	Include system definitions we need.
//
#include <cstdio>

//
//	Include the base set of definitions (types, constants etc).
//
#include "Base.h"

//
//	Include the hardware object APIs we need.
//
#include "Memory.h"
#include "Flash.h"
#include "Interrupts.h"
#include "Clock.h"
#include "CPU.h"

//
//	Also need to be able to raise software exceptions
//
#include "Exception.h"

//
//	Pre-Declare the Instruction and AVR_CPU classes.
//
//	This is needed as the Instruction and AVR_CPU classes
//	refer to each other.
//
class Instruction;
class AVR_CPU;

//
//	Declare the look up function as defined at the end of
//	the source file.
//
extern Instruction *find_instruction( word opcode );
{BF}


{BH}
//
//	Enumerate the various AVR MCUs we shall aim
//	to simulate.
//
typedef enum {
	//
	//	Define the different AVR architectures
	//			
	AVR_MCU		= 0,	// "AVR"	Original instruction set from 1995.
	
	AVRe_MCU	= 1,	// "megaAVR"	Multiply (xMULxx), Move Word (MOVW),
				//		and enhanced Load Program Memory (LPM)
				//		added to the AVR instruction set.
				
	AVRet_MCU	= 2,	// "tinyAVR"	Multiply not included, but else equal
				//		to AVRe for megaAVR ("et" is my label
				//		to apply to this option).
				
	AVRxm_MCU	= 3,	// "XMEGA"	The Read Modify Write (RMW) and
				//		DES encryption instructions are
				//		unique to this version.
				
	AVRxt_MCU	= 4,	// "AVR"	Base AVR from 2016 and onwards.
	
	AVRrc_MCU	= 5	// "tinyAVR"	The Reduced Core AVR CPU.
} AVR_Type;

//
//	Define the number of types we will support (as above).
//
const byte AVR_Types = 6;
{BF}

Define the class used to hold the AVR CPU state information, and
provide the CPU class API routines to allow the simulation to be
executed.

{BH}
//
//	The AVR CPU State
//
class AVR_CPU : public CPU {
	private:
		//
		//	Exception handler.
		//
		Exception	*_error;

		//
		//	Which CPU are we?
		//
		AVR_Type	_cpu;

		//
		//	Program address size in BITS and the number of bytes
		//	required to hold that many bits.
		//
		byte		_pas_bits,
				_pas_bytes;
		
		//
		//	Where do we find the program to execute?
		//
		Flash		*_program;

		//
		//	The various element of memory:
		//
		Memory		*_data,
				*_regs,
				*_io,
				*_ext_io,
				*_sram;

		//
		//	Where we collect and manage IRQs.
		//
		Interrupts	*_irqs;

		//
		//	Where the CPU clock is simulated.
		//
		Clock		*_clock;

		//
		//	Transient internal CPU flags.
		//
		bool		_skip_next;		// Step to true to skip next instruction.

		//
		//	The Status Register
		//	===================
		//
		//	Define the IO port where the status register
		//	is found.
		//
		static const word status_register = 0x3F;
		
		//
		//	Pointer to the Status Register location.
		//
		byte		*_sr;

		//
		//	The Program Counter
		//	===================
		//
		//	This has no presence in the address space (unlike the
		//	stack pointer and status register), so only needs a
		//	simple variable to hold it.
		//
		//	Also define the mask value which is applied to the PC
		//	to control its range (simulating a fixed number of bits).
		//
		dword		_pc,
				_pc_mask;

		//
		//	The Stack Pointer (effectively 16 bit).
		//	=======================================
		//
		//	Define the IO ports where the stack pointer
		//	is found.
		//
		static const word stack_pointer_h = 0x3E;
		static const word stack_pointer_l = 0x3D;
		//
		//	Pointers to the Stack Pointer individual locations.
		//
		byte		*_sp_h,
				*_sp_l;
		
		//
		//	Stack Pointer access routines.
		//
		inline word get_SP( void ) { return( combine( *_sp_h, *_sp_l )); }
		inline void set_SP( word sp ) { *_sp_l = low( sp ); *_sp_h = high( sp ); }

	public:
		//
		//	AVR_CPU CONSTRUCTOR
		//	=====================
		//
		//	The AVR class emulates a number of AVR class CPUs, selectable
		//	when the object is initialised.
		//
		AVR_CPU(		AVR_Type	cpu,
					byte		pas,		// Program Address size (bits)
					Flash		*program,	
					Memory		*data,
					Memory		*regs,
					Memory		*io,
					Memory		*ext_io,
					Memory		*sram,
					Interrupts	*irqs,
					Clock		*clock,
					Exception	*handler );
{BS}
		//
		//	AVR_CPU CONSTRUCTOR
		//	=====================
		//
		//	The AVR class emulates a number of AVR class CPUs, selectable
		//	when the object is initialised.
		//
		AVR_CPU::AVR_CPU(	AVR_Type	cpu,
					byte		pas,		// Program Address size (bits)
					Flash		*program,	
					Memory		*data,
					Memory		*regs,
					Memory		*io,
					Memory		*ext_io,
					Memory		*sram,
					Interrupts	*irqs,
					Clock		*clock,
					Exception	*handler ) {
			//
			//	CPU type, and program address size in bits and bytes.
			//
			_cpu = cpu;
			_pas_bits = pas;
			_pas_bytes = ( _pas_bits + 7 ) >> 3;
			//
			//	Define the mask applied to the PC every
			//	time it is adjusted.
			//
			_pc_mask = ((dword)1 << _pas_bits ) - 1;
			//
			//	Flashed program memory.
			//
			_program = program;
			//
			//	Memory in its various forms.
			//
			_data = data;
			_regs = regs;
			_io = io;
			_ext_io = ext_io;
			_sram = sram;
			//
			//	Interrupt mechanism
			//
			_irqs = irqs;
			//
			//	The CPU clock
			//
			_clock = clock;
			//
			//	Set CPU flags.
			//
			_skip_next = false;
			//
			//	Save the error handler.
			//
			_error = handler;
			//
			//	Set up Status Register pointer.
			//
			_sr = _io->at( status_register );
			//
			//	Set up the Stack Pointer pointers.
			//
			_sp_h = _io->at( stack_pointer_h );
			_sp_l = _io->at( stack_pointer_l );
			//
			//	Reset internal registers.
			//
			reset();
		}
{BH}
		//
		//	Value Manipulation
		//	------------------
		//
		//	Routines to combine byte, word values up to word
		//	and dword, and split words and dwords down.
		//
		static inline byte high( word v ) { return(( v >> 8 ) & 0xFF ); }
		static inline word highw( dword v ) { return(( v >> 16 ) & 0xFFFF ); }
		static inline byte low( word v ) { return( v & 0xFF ); }
		static inline word loww( dword v ) { return( v & 0xFFFF ); }
		static inline word combine( byte h, byte l ) { return( ((word)h << 8 ) | ((word)l )); }
		static inline dword combinew( word h, word l ) { return( ((dword)h << 16 ) | ((dword)l )); }

		//
		//	Data Registers
		//	==============
		//
		byte read_reg( word reg ) { return( _regs->read( reg )); }
		void write_reg( word reg, byte val ) { _regs->write( reg, val ); }

		//
		//	IO Registers
		//	============
		//
		byte read_io( word io ) { return( _io->read( io )); }
		void write_io( word io, byte val ) { _io->write( io, val ); }

		//
		//	Status Register
		//	===============
		//
		//	Testing and setting routines.
		//

		//
		//	Get/Set Status register as a whole.
		//
		inline byte get_sr( void ) { return( *_sr ); }
		inline void set_sr( byte val ) { *_sr = val; }
		
		//	I: Global Interrupt Enable
		//	--------------------------
		//
		inline bool get_I( void ) { return( *_sr & 0x80 ); }
		inline void set_I( bool v ) { *_sr = ( *_sr & ~0x80 )|( v? 0x80: 0x00 ); }
		//
		//	T: Bit Copy Storage
		//	-------------------
		//
		inline bool get_T( void ) { return( *_sr & 0x40 ); }
		inline void set_T( bool v ) { *_sr = ( *_sr & ~0x40 )|( v? 0x40: 0x00 ); }
		//
		//	H: Half Carry Flag
		//	------------------
		//
		inline bool get_H( void ) { return( *_sr & 0x20 ); }
		inline void set_H( bool v ) { *_sr = ( *_sr & ~0x20 )|( v? 0x20: 0x00 ); }
		//
		//	S: Sign Bit
		//	-----------
		//
		inline bool get_S( void ) { return( *_sr & 0x10 ); }
		inline void set_S( bool v ) { *_sr = ( *_sr & ~0x10 )|( v? 0x10: 0x00 ); }
		//
		//	V: Two’s Complement Overflow Flag
		//	---------------------------------
		//
		inline bool get_V( void ) { return( *_sr & 0x08 ); }
		inline void set_V( bool v ) { *_sr = ( *_sr & ~0x08 )|( v? 0x08: 0x00 ); }
		//
		//	N: Negative Flag
		//	----------------
		//
		inline bool get_N( void ) { return( *_sr & 0x04 ); }
		inline void set_N( bool v ) { *_sr = ( *_sr & ~0x04 )|( v? 0x04: 0x00 ); }
		//
		//	Z: Zero Flag
		//	------------
		//
		inline bool get_Z( void ) { return( *_sr & 0x02 ); }
		inline void set_Z( bool v ) { *_sr = ( *_sr & ~0x02 )|( v? 0x02: 0x00 ); }
		//
		//	C: Carry Flag
		//	-------------
		//
		inline bool get_C( void ) { return( *_sr & 0x01 ); }
		inline void set_C( bool v ) { *_sr = ( *_sr & ~0x01 )|( v? 0x01: 0x00 ); }

		//
		//	Stack Pointer.
		//	==============
		//
		//	Routines for storing and retrieving data from the stack.
		//
		void push_byte( byte v ) {
			word sp = get_SP();
			_data->write( sp--, v );
			set_SP( sp );
		}
		void push_word( word v ) {
			word sp = get_SP();
			//
			//	Push MSB first to maintain little-endian
			//	data order in memory.
			//
			_data->write( sp--, high( v ));
			_data->write( sp--, low( v ));
			set_SP( sp );
		}
		byte pop_byte( void ) {
			word sp = get_SP();
			byte v = _data->read( ++sp );
			set_SP( sp );
			return( v );
		}
		word pop_word( void ) {
			word sp = get_SP();
			//
			//	Pop LSB first as this is the reverse of
			//	the push action.
			//
			byte l = _data->read( ++sp );
			byte h = _data->read( ++sp );
			set_SP( sp );
			return( combine( h, l ));
		}
		//
		//	Specific PC push and pop routines (as the size of the
		//	program counter varies) and a direct set PC function.
		//
		//	Push also assigns a new value to the PC (as per call).
		//
		void push_pc( dword adrs ) {
			switch( _pas_bytes ) {
				case 1: {
					push_byte( low( _pc ));
					break;
				}
				case 2: {
					push_word( _pc );
					break;
				}
				case 3: {
					push_byte( low( highw( _pc )));
					push_word( loww( _pc ));
					break;
				}
				default: {
					_error->raise( Invalid_PAS );
				}
			}
			_pc = adrs & _pc_mask;
		}
		void pop_pc( void ) {
			switch( _pas_bytes ) {
				case 1: {
					_pc = pop_byte() & _pc_mask;
					break;
				}
				case 2: {
					_pc = pop_word() & _pc_mask;
					break;
				}
				case 3: {
					_pc = pop_word();
					_pc |= ((dword)pop_byte()) << 16;
					_pc &= _pc_mask;
					break;
				}
				default: {
					_error->raise( Invalid_PAS );
				}
			}
		}

		//
		//	Program Counter
		//	===============
		//
		//	Routines to obtain and manipulate the program counter register.
		//
		inline dword get_pc( void ) {
			return( _pc );
		}
		inline void set_pc( dword adrs ) {
			_pc = adrs & _pc_mask;
		}
		inline void inc_pc( dword rel ) {
			_pc = ( _pc + rel ) & _pc_mask;
		}
			
		//
		//	Read next program word (move PC forward).
		//
		word next_opcode( void ) {
			word	next;
			//
			//	Simples..
			//
			next = _program->read( _pc );
			_pc = ( _pc + 1 ) & _pc_mask;
			return( next );
		}

		//
		//	Peek ahead into the program with an offset from the PC
		//	Only accepts positive offsets ahead of the PC.
		//
		word peek_ahead( word offset ) {
			//
			//	Simples..
			//
			return( _program->read(( _pc + offset ) & _pc_mask ));
		}

		//
		//	Mark the next instruction to be executed as "to
		//	be ignored".
		//
		void set_skip_next( void ) {
			_skip_next = true;
		}

		//
		//	Exception handling
		//	==================
		//
		//	Links through back to the Exceptions object pointed
		//	to be '_error'
		//
		bool raise( Errors number ) {
			return( _error->raise( number ));
		}
		bool raise( Errors number, word arg ) {
			return( _error->raise( number, arg ));
		}
		bool raise( Errors number, dword arg1, word arg2 ) {
			return( _error->raise( number, arg1, arg2  ));
		}
		bool raise( Errors number, const char *mesg ) {
			return( _error->raise( number, mesg ));
		}
		bool raise( Errors number, const char *file, word line ) {
			return( _error->raise( number, file, line ));
		}

		//
		//	Internal state access routines
		//	==============================
		//
		AVR_Type mcu_type( void ) { return( _cpu ); }
		byte get_pas_bits( void ) { return( _pas_bits ); }
		byte get_pas_bytes( void ) { return( _pas_bytes ); }

		//
		//	Class CPU API Routines.
		//	=======================
		//
		
		//
		//	Reset CPU to initial condition ready for first
		//	instruction execution.
		//
		virtual void reset( void );
{BS}	
		//
		//	Reset CPU to initial condition ready for first
		//	instruction execution.
		//
		void AVR_CPU::reset( void ) {	
			//
			//	Clear any pending interrupts.
			//
			_irqs->reset();

			//
			//	Status register cleared; global interrupts
			//	disabled.
			//
			*_sr = 0;
			
			//
			//	Stack pointer set to the last byte of memory.
			//
			set_SP( _data->capacity()-1 );
			
			//
			//	Program Counter set start of flash memory.
			//
			_pc = 0x0000;
		}

{BH}
		//
		//	Execute a single instruction, move PC forward, accepts
		//	interrupts etc as necessary.
		//
		virtual void step( void );

{BS}
		//
		//	Execute a single instruction, move PC forward, accepts
		//	interrupts etc as necessary.
		//
		void AVR_CPU::step( void ) {
			Instruction	*inst;
			word		opcode,
					ticks;
			
			//
			//	Step One:	If the _skip_next flag is set
			//			then identify the target instruction
			//			and move over it.
			//
			//			During this period there can be no
			//			interrupts which is why it is the first
			//			action in the instruction handling code.
			//
			if( _skip_next ) {
				_skip_next = false;
				inst = find_instruction( peek_ahead( 0 ));
				ticks = inst->size();
				inc_pc( ticks );
				//
				//	The combination of these clock ticks and those
				//	used by any instruction which sets the _skip_next
				//	flag gives the correct overall clock count.
				//
				_clock->tick( ticks );
			}
			
			//
			//	Step Two:	Interrupts enabled?  If there are
			//			then redirect actions to the IRQ Vector.
			//
			if( get_I()) {
				byte	irq;
				
				//
				//	Look for a pending interrupt..
				//
				if( _irqs->find( &irq )) {
					//
					//	We have an interrupt pending, so we need
					//	to do a couple of things:
					//
					//	1/ Reset the I flag.
					//	2/ Clear the causal interrupt.
					//	3/ Stack the program counter and set the program
					//	   counter to the right vector.
					//
					//	We set the PC to the address of the interrupt 'vector',
					//	though this is not a vector (in my opinion).
					//
					//	At each IRQ target address are two words (before the next
					//	IRQ target address) which is enough space for an absolute
					//	jump or two single word instructions.
					//
					set_I( false );
					_irqs->clear( irq );
					push_pc( (dword)irq << 1 );
					//
					//	The following is, honestly, an educated guess;
					//
					//	The above actions take the following durations:
					//
					//		Clear I			1 cycle
					//		Clear IRQ		1 cycle
					//		Stack PC		_pas_bytes cycles
					//		Load PC			1 cycle
					//	
					//	The AVR Documentation says the *minimum* time is 4 cycles,
					//	which would be right for the very smallest AVR MCUs (those
					//	with 8 bit program counters?)
					//
					_clock->tick( _pas_bytes + 3 );
				}
			}
		
			//
			//	Step Three:	Obtain the opcode word at the
			//			current PC value and identify
			//			the associated instruction.
			//
			//			Then execute it.
			//
			opcode = next_opcode();
			inst = find_instruction( opcode );
			_clock->tick( inst->execute( opcode, this ));
		}

{BH}

		//
		//	Disassemble the instruction at location PC+offset.
		//
		//	Returns number of opcodes used by the disassembly.
		//
		virtual word disassemble( word offset, char *buffer, int max );

{BS}
		//
		//	Disassemble the instruction at location PC+offset.
		//
		//	Returns number of opcodes used by the disassembly.
		//
		word AVR_CPU::disassemble( word offset, char *buffer, int max ) {
			word		opcode = peek_ahead( 0 );
			Instruction	*inst = find_instruction( opcode );
			return( inst->disassemble( opcode, this, buffer, max ));
		}

{BH}
};
{BF}


{BH}
//
//	Define a virtual class to be used to handle
//	the methods that implement an instruction.
//
class Instruction {
	protected:
{BC}
		The following definitions are made available to the implementation file
		to simplify the definition of the individual instructions actions.
{BH}
		//
		//	Sign extension routine.
		//
		template<class t, word n> static inline t sign_extend( t value ) {
			const t sign_bit = ((t)1)<<(n-1);
			const t sign_fill = ~((sign_bit<<1)-1);
			if( value & sign_bit ) value |= sign_fill;
			return( value );
		}
 

		//
		//	4 bit oriented.
		//
		static inline byte nibble( byte v ) {
			return( v & 0x0F );
		}
{BC}
		Half carry generated if the bottom nibbles added together
		exceed the capacity of a single decimal digit (10 or above).

		Used by code performing BCD maths to correct answers after
		addition.  Is this still used anywhere?
{BH}
		static inline bool half( byte a, byte b ) {
			return(( nibble( a ) + nibble( b )) > 9 );
		}
{BC}
		Borrow is generated when the bottom nibble of a is smaller
		than the bottom nibble of b.  In a subtraction this would
		cause a "borrowed" bit from the higher nibble to be carried
		down.
{BH}
		static inline bool borrow( byte a, byte b ) {
			return( nibble( a ) < nibble( b ));
		}

		//
		//	8 bit oriented
		//
		static inline bool odd( byte v ) {
			return( v & 0x01 );
		}
		static inline bool sign( byte v ) {
			return( v & 0x80 );
		}
{BC}
		Return indication of signed Overflow if b were added to a
		resulting in c.
{BH}
		static inline bool overflow( byte a, byte b, byte c ) {
			return(( sign( a ) == sign( b ))&&( sign( a ) != sign( c )));
		}
{BC}
		Return indication of signed Underflow if b were subtracted
		from a resulting in c.  This is, in effect, the inverse of
		signed overflow.
{BH}
		static inline bool underflow( byte a, byte b, byte c ) {
			return( !overflow( a, b, c ));
		}

		static inline bool carry( word v ) {
			return( v & 0x0100 );
		}

		//
		//	16 bit oriented.
		//
		static inline bool signw( word v ) {
			return( v & 0x8000 );
		}
		static inline byte lsb( word v ) {
			return( (byte)v );
		}
		static inline byte msb( word v ) {
			return( v >> 8 );
		}
		static inline word combine( byte h, byte l ) {
			return(( (word)h << 8 ) | (word)l );
		}

		//
		//	32 bit oriented.
		//
		static inline word msw( dword v ) {
			return( v >> 16);
		}
		static inline dword combinew( word h, word l ) {
			return(( (dword)h << 16 ) | (dword)l );
		}

		//
		//	Provide a set of routines for breaking down op codes
		//	into their component parts.
		//
		//	Bit assignments: 
		//
		//	rrrrr	= Source register (R0-R31)
		//	ddddd	= Destination register (R0-R31)
		//
		//		____ __r_ ____ rrrr
		//		____ ___d dddd ____
		//
		static inline word arg_r0_r31( word op ) { return(( op & 0x000F )|(( op >> 5 ) & 0x0010 )); }
		static inline word arg_d0_d31( word op ) { return(( op >> 4 ) & 0x001F ); }

		//
		//	rrrr	= Source register (R16–R31)
		//	dddd	= Destination register (R16–R31)
		//
		//		____ ____ ____ rrrr
		//		____ ____ dddd ____
		//
		static inline word arg_r16_r31( word op ) { return(( op & 0x000F ) + 16 ); }
		static inline word arg_d16_d31( word op ) { return((( op >> 4 ) & 0x000F ) + 16 ); }
		//
		//		____ ____ ____ _rrr
		//		____ ____ _ddd ____
		//
		//	rrr	= Source register (R16–R23)
		//	ddd	= Destination register (R16–R23)
		//
		static inline word arg_r16_r23( word op ) { return(( op & 0x0007 ) + 16 ); }
		static inline word arg_d16_d23( word op ) { return((( op >> 4 ) & 0x0007 ) + 16 ); }

		//
		//	RRRR	= Source register pair (R1:R0–R31:R30)
		//	DDDD	= Destination register pair (R1:R0–R31:R30)
		//
		//		____ ____ DDDD ____
		//		____ ____ ____ RRRR
		//
		//	Routines below return even numbers 0 through 30 (16 distinct values)
		//
		static inline word arg_r1r0_r31r30( word op ) { return(( op & 0x000F ) << 1 ); }
		static inline word arg_d1d0_d31d30( word op ) { return(( op >> 3 ) & 0x001E ); }

		//
		//	dd	= Register pair W, X, Y or Z (R25:R24, R27:R26, R29:R28, R31:R30)
		//
		//		____ ____ __dd ____
		//
		//		Routine below returns even numbers 24 through 30 (4 distinct values)
		//
		static inline word arg_d24d25_d30d31( word op ) { return((( op >> 3 ) & 0x0006 ) + 24 ); }
		static inline char arg_WXYZ( word op ) { return( 'W' + (( op >> 4 ) & 0x0003 )); }

		//
		//	aaaaaa	= I/O space address
		//	aaaaa	= I/O space address (first 32 only)
		//
		//		____ _aa_ ____ aaaa
		//		____ ____ aaaa a___
		//
		static inline word arg_a0_a63( word op ) { return(( op & 0x00F )|(( op >> 5 ) & 0x0030 )); }
		static inline word arg_a0_a31( word op ) { return(( op >> 3 ) & 0x001F ); }

		//
		//	bbb	= Bit number (0–7)
		//	sss	= Flag in SREG
		//
		//		____ ____ ____ _bbb
		//		____ ____ _sss ____
		//
		//	Also provide flag index back to letter routine.
		//
		static inline word arg_bit( word op ) { return( op & 0x0007 ); }
		static inline word arg_bit_mask( word op ) { return((word)1 << ( op & 0x0007 )); }
		static inline word arg_flag( word op ) { return(( op >> 4 ) & 0x0007 ); }
		static inline word arg_flag_mask( word op ) { return((word)1 << (( op >> 4 ) & 0x0007 )); }
		static inline char disp_flag( word flag ) {
			static const char flags[ 8 ] = { 'C', 'Z', 'N', 'V', 'S', 'H', 'T', 'I' };
			if( flag > 7 ) return( '?' );
			return( flags[ flag ]);
		}

		//
		//	kkkk		= 4-bit unsigned constant (DES opcode)
		//	KKKKKK		= 6-bit unsigned constant (adiw/sbiw word constant)
		//	kkkkkk		= 6-bit unsigned constant (YZ offset)
		//	KKKKKKKK	= 8-bit (un)signed constant (sign not meaningful in this context)
		//	kkkkkkkkkkkk	= 12 bit signed constant (relative calls/jumps)
		//
		//		____ ____ kkkk ____	4
		//		____ ____ KK__ KKKK	6_w (adiw/sbiw)
		//		__k_ kk__ ____ _kkk	6_o (YZ offset)
		//		____ KKKK ____ KKKK	8
		//		____ kkkk kkkk kkkk	12
		//
		static word arg_imm4( word op ) { return(( op >> 4 ) & 0x000F ); }
		static word arg_imm6_w( word op ) { return(( op & 0x000F )|(( op >> 2 ) & 0x0030 )); }
		static word arg_imm6_o( word op ) { return(( op & 0x0007 )|(( op >> 7 ) & 0x0018 )|(( op >> 8 ) & 0x0020 )); }
		static word arg_imm8( word op ) { return(( op & 0x000F )|(( op >> 4 ) & 0x00F0 )); }

		//
		//	jjjjjj +16	= 6-bit and 16-bit unsigned constant (absolute PC)
		//	jjjjjjj		= 7-bit signed constant (relative branching)
		//	jjjjjjjjjjjj	= 12-bit signed constant (relative PC)
		//	
		//		____ ___j jjjj ___j	6 then 16 following.
		//		____ __jj jjjj j___	7
		//		____ jjjj jjjj jjjj	12
		//
		static dword arg_absolute( word op, word arg ) { return( combinew((( op & 0x0001 ) | (( op >> 3 ) & 0x003E )), arg )); }
		static dword arg_branch( word op ) { return( sign_extend<dword,7>(( op >> 3 ) & 0x7F )); }
		static dword arg_relative( word op ) { return( sign_extend<dword,12>( op & 0x0FFF )); }

		//
		//	Routine returns number of bits set in a byte value.  Rather than
		//	a 256 element table, we will use a 16 element table, twice.
		//
		static byte count_ones( byte value ) {
			static byte counted[ 16 ] = {	0, 1, 1, 2,	// 0000 0001 0010 0011
							1, 2, 2, 3,	// 0100 0101 0110 0111
							1, 2, 2, 3,	// 1000 1001 1010 1011
							2, 3, 3, 4	// 1100 1101 1110 1111
			};
			return( counted[ value >> 4 ] + counted[ value & 0xF ]);
		}
	public:
		//
		//	Execute an instruction against an AVR state.
		//
		//	Return the number of CPU clock cycles taken to
		//	execute the instruction.  If ZERO is returned
		//	the instruction is not valid on this CPU.
		//
		virtual word execute( word opcode, AVR_CPU *state ) = 0;
		//
		//	Return the number of program words required to
		//	hold the instruction with the supplied opcode.
		//
		//	The default routine returns 1, the most common answer.
		//
		virtual word size( void ) { return( 1 ); }
		//
		//	Fill an buffer with the mnemonic of the instruction.
		//
		//	Return number of program words required to fully
		//	disassemble the instruction.
		//
		virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) = 0;
};


#endif

//
//	EOF
//
{BF}

The Decode Implementation File
==============================

The start of the decoding details:

{BS}
//
//	Define the decoder node type.
//
typedef struct {
	word		mask,		// Which bit do we test (no word index required).
			jump;		// How many to jump if bit is 1.
	Instruction	*data;		// The data structure to return address of.
} decoder_entry;
{BF}


At the end of the file we define the lookup function itself.

{BE}
//
//	The lookup function.
//
Instruction *find_instruction( word opcode ) {
	decoder_entry	*ptr;
	word		test;

	ptr = decode_table;
	while(( test = ptr->mask )) ptr += ( opcode & test )? ptr->jump: 1;
	return( ptr->data );
}

//
//	EOF
//
{BF}

Finally, define a C character string that contains the 'lead-in'
characters for hexidecimal constant values (when displayed by the
disassembly routines).

{ #define HEX "0x" }


AVR Instruction Table
=====================

Define the specific details that the decoder encoder needs to know:

	{Z 16 }
	{W 1 }
	{S static }
	{T decoder_entry }
	{N decode_table }

The output table will point to an instance of class Instruction which
contains methods that enact the various aspects of the identified instruction.

The individual instruction pointers are processed according to the following
'F' record meaning that an instruction 'adc' will be inserted into the lookup
table as '&( adc_inst )'.

	{F &( %_inst )}

Define the 'illegal' instruction implementation.

	{E illegal }
	
{BS}
static class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	Called when any decoded opcode does not uniquely identify a
		//	single specific instruction.
		//
		if( state->raise( Illegal_Instruction, state->get_pc()-1, opcode )) return( 0 );
		//
		//	Action here will depend on the CPU being
		//	simulated.
		//
		//	At present nothing is being done on any CPU.
		//
		switch( state->mcu_type()) {
			case AVR_MCU: {
				break;
			}
			case AVRe_MCU: {
				break;
			}
			case AVRet_MCU: {
				break;
			}
			case AVRxm_MCU: {
				break;
			}
			case AVRxt_MCU: {
				break;
			}
			case AVRrc_MCU: {
				break;
			}
			default: {
				//
				//	Default is to ignore the illegal instruction
				//	and continue program execution.
				//
				break;
			}
		}
		//
		//	All illegal instructions, if ignored, take one cycle.
		//
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "illegal " HEX "%04X", opcode );
		return( 1 );
	}
} illegal_inst;
{BF}

The remainder of this document captures each of the instructions.  The order of
the instructions encoding and actions is taken from the PDF document referenced
at the start (AVR-Instruction-Set-Manual-DS40002198A).

The section numbers provided with the instruction title reference directly back to
this document.

The details below summarise the arguments which are encoded into the opcodes of
AVR instructions.

	Opcode argument bits: 

		rrrrr	= Source register (R0-R31)
		ddddd	= Destination register (R0-R31)
		
		rrrr	= Source register (R16–R31)
		dddd	= Destination register (R16–R31)
		
		rrr	= Source register (R16–R23)
		ddd	= Destination register (R16–R23)
		
		RRRR	= Source register pair (R1:R0–R31:R30)
		DDDD	= Destination register pair (R1:R0–R31:R30)
		
		dd	= Register pair W, X, Y or Z (R25:R24, R27:R26, R29:R28, R31:R30)
		
		aaaaaa	= I/O space address
		aaaaa	= I/O space address (first 32 only)
		
		bbb	= Bit number (0–7)
		sss	= Flag in SREG (bit number 0-7)
		
		kkkk	= 4-bit unsigned constant (DES opcode)
		kkkkkk	= 6-bit unsigned constant
		KKKKKKKK= 8-bit constant

		jjjjjjj	= 7-bit signed constant (relative branching)


5.1. ADC – Add with Carry
=========================

{I 000111rdddddrrrr adc }	ADC Rd,Rr		Rd = Rd + Rr + C	(ROL Rd when Rd==Rr)

{BS}
//
//	ADC Rd,Rr		Rd = Rd + Rr + C	(ROL Rd when Rd==Rr)
//	
static class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 11rd dddd rrrr
		//
		byte	dr, dv,		// Destination register and value
			rv,		// Argument register value
			bv;		// Byte result
		word	wv;		// Word result
		bool	c, n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode )) + ( state->get_C()? 1: 0 );
		bv = lsb( wv = dv + rv );
		state->set_H( half( dv, rv ));
		state->set_V( v = overflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	dr, rr;
		
		if(( dr = arg_d0_d31( opcode )) == ( rr = arg_r0_r31( opcode ))) {
			snprintf( buffer, max, "rol r%d", (int)dr );
		}
		else {
			snprintf( buffer, max, "adc r%d,r%d", (int)dr, (int)rr );
		}
		return( 1 );
	}
} adc_inst;
{BF}


5.2. ADD – Add without Carry
============================

{I 000011rdddddrrrr add }	ADD Rd,Rr		Rd = Rd + Rr		(LSL Rd when Rd==Rr)

{BS}
//
//	ADD Rd,Rr		Rd = Rd + Rr		(LSL Rd when Rd==Rr)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 11rd dddd rrrr
		//
		byte	dr, dv,		// Destination register and value
			rv,		// Argument register value
			bv;		// Byte result
		word	wv;		// Word result
		bool	c, n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode ));
		bv = lsb( wv = dv + rv );
		state->set_H( half( dv, rv ));
		state->set_V( v = overflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		word	dr, rr;
		
		if(( dr = arg_d0_d31( opcode )) == ( rr = arg_r0_r31( opcode ))) {
			snprintf( buffer, max, "lsl r%d", (int)dr );
		}
		else {
			snprintf( buffer, max, "add r%d,r%d", (int)dr, (int)rr );
		}
		return( 1 );
	}
} add_inst;
{BF}


5.3. ADIW – Add Immediate to Word
=================================
	
{I 10010110KKddKKKK adiw }	ADIW Rd,k		Rd+1:Rd += k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)

Note:
	The below 'adiw' (and 'sbiw') instructions can be considered to be
	as (mnemonically) operating against the registers W, X, Y or Z.
	In this case the instructions could be viewed as:

		ADIW	[WXYZ],k
	and
		SBIW	[WXYZ],k
		

{BS}
//
//	ADIW Rd,k		Rd+1:Rd += k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0110 KKdd KKKK
		//
		static byte ticks[ AVR_Types ] = { 2, 2, 2, 2, 2, 0 };
		
		word	clocks,
			dr, dv,
			wv, kk;
		bool	n, v;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		dr = arg_d24d25_d30d31( opcode );
		dv = combine( state->read_reg( dr+1 ),  state->read_reg( dr ));
		kk = arg_imm6_w( opcode );
		wv = dv + kk;
		state->set_V( v = ( signw( dv ) != signw( wv )));
		state->set_N( n = signw( wv ));
		state->set_S( n ^ v );
		state->set_C(( signw( dv ))&&( !signw( wv )));
		state->set_Z( wv == 0 );
		state->write_reg( dr, lsb( wv ));
		state->write_reg( dr + 1, msb( wv ));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "adiw %c," HEX "%02X", arg_WXYZ( opcode ), (int)arg_imm6_w( opcode ));
		return( 1 );
	}
} adiw_inst;
{BF}


5.4 AND – Logical AND
=====================

{I 001000rdddddrrrr and }	AND Rd,Rr		Rd = Rd & Rr

{BS}
//
//	AND Rd,Rr		Rd = Rd & Rr
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0010 00rd dddd rrrr
		//
		word	dr, dv,
			rv,
			vv;
		bool	n;
		
		rv = state->read_reg( arg_r0_r31( opcode ));
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		vv = rv & dv;
		state->set_V( false );
		state->set_N( n = sign( vv ));
		state->set_S( n );
		state->set_Z( vv == 0 );
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "and r%d,r%d", (int)arg_d0_d31( opcode ), (int)arg_r0_r31( opcode ));
		return( 1 );
	}
} and_inst;
{BF}


5.5 ANDI – Logical AND with Immediate
=====================================

{I 0111KKKKddddKKKK andi }	ANDI Rd,K		Rd = Rd & K		(And with 8-bit immediate. Alias: CBR Rd,~K)

{BS}
//
//	ANDI Rd,K		Rd = Rd & K		(And with 8-bit immediate. Alias: CBR Rd,~K)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0111 KKKK dddd KKKK
		//
		word	dr, vv;
		bool	n;
		
		vv = state->read_reg( dr = arg_d16_d31( opcode )) & arg_imm8( opcode );
		state->set_V( false );
		state->set_N( n = sign( vv ));
		state->set_S( n );
		state->set_Z( vv == 0 );
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:	This instruction (ANDI) is aliased as 'Clear bits in Register' (CBR Rd,K).
		The disassembly routine will note this and display the appropriate version
		based on the number of bits set in the constant argument supplied.

		With 4 or less bits set this is assumed to be an ANDI instruction, with 5
		or more bits this is assumed to be a CBR instruction.
{BS}
		byte	imm8 = arg_imm8( opcode );
	
		if( count_ones( imm8 ) > 4 ) {
			snprintf( buffer, max, "cbr r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)(~imm8));
		}
		else {
			snprintf( buffer, max, "andi r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)imm8);
		}
		return( 1 );
	}
} andi_inst;
{BF}


5.6 ASR – Arithmetic Shift Right
================================

{I 1001010ddddd0101 asr }	ASR Rd		Rd = Rd / 2		(Arithmetic right shift)

{BS}
//
//	ASR Rd		Rd = Rd / 2		(Arithmetic right shift)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0101
		//
		word	dr, dv,
			vv;
		bool	n;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		state->set_N( n = sign( dv ));
		vv = ( dv >> 1 ) | ( n? 0x80: 0x00 );
		state->set_V( false );
		state->set_S( n );
		state->set_Z( vv == 0 );
		state->set_C( odd( dv ));
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "asr r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} asr_inst;
{BF}


5.7 BCLR – Bit Clear in SREG
============================

{I 100101001sss1000 bclr }	BCLR s		SREG[s] = 0		(0 <= d <= 31, 0 <= b <= 7)

{BS}
//
//	BCLR s		SREG[s] = 0		(0 <= d <= 31, 0 <= b <= 7)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 1sss 1000
		//
		state->set_sr( state->get_sr() & ~arg_flag_mask( opcode ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int f = arg_flag( opcode );
		snprintf( buffer, max, "bclr %d(%c)", f, disp_flag( f ));
		return( 1 );
	}
} bclr_inst;
{BF}


5.8 BLD – Bit Load from the T Bit in SREG to a Bit in Register
==============================================================

{I 1111100ddddd0bbb bld }	BLD Rd,b		Rd[b] = T

{BS}
//
//	BLD Rd,b		Rd[b] = T
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 100d dddd 0bbb
		//
		word	dr, dv;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		if( state->get_T()) {
			dv |= arg_bit_mask( opcode );
		}
		else {
			dv &= ~arg_bit_mask( opcode );
		}
		state->write_reg( dr, dv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "bld r%d,%d", arg_d0_d31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} bld_inst;
{BF}


5.9 BRBC – Branch if Bit in SREG is Cleared
===========================================

{I 111101jjjjjjjbbb brbc }	BRBC s,k		If SREG(s) == 0 then PC ← PC + k + 1, else PC ← PC + 1

{BS}
//
//	BRBC s,k		If SREG(s) == 0 then PC ← PC + k + 1, else PC ← PC + 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 01jj jjjj jbbb
		//
		if(( state->get_sr() & arg_bit_mask( opcode )) == 0 ) {
			state->inc_pc( arg_branch( opcode ));
			return( 2 );
		}
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		static const char *test[ 8 ] = { "cc", "ne", "pl", "vc", "ge", "hc", "tc", "id" };
		snprintf( buffer, max, "br%s %d", test[ arg_bit( opcode )], (int)arg_branch( opcode ));
		return( 1 );
	}
} brbc_inst;
{BF}


5.10 BRBS – Branch if Bit in SREG is Set
========================================

{I 111100jjjjjjjbbb brbs }	BRBS s,k		If SREG(s) == 1 then PC ← PC + k + 1, else PC ← PC + 1

{BS}
//
//	BRBS s,k		If SREG(s) == 1 then PC ← PC + k + 1, else PC ← PC + 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 01jj jjjj jbbb
		//
		if(( state->get_sr() & arg_bit_mask( opcode )) != 0 ) {
			state->inc_pc( arg_branch( opcode ));
			return( 2 );
		}
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		static const char *test[ 8 ] = { "cs", "eq", "mi", "vs", "lt", "hs", "ts", "ie" };
		snprintf( buffer, max, "br%s %d", test[ arg_bit( opcode )], (int)arg_branch( opcode ));
		return( 1 );
	}
} brbs_inst;
{BF}


5.11 BRCC – Branch if Carry Cleared
===================================

	See BRBC 0,j


5.12 BRCS – Branch if Carry Set
===============================

	See BRBS 0,j


5.13 BREAK – Break
==================

{I 1001010110011000 break }	BREAK

{BS}
//
//	BREAK						(Stop CPU, enter debug mode)
//	
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0101 1001 1000
		//
		static byte ticks[ AVR_Types ] = { 0, 1, 1, 1, 1, 1 };
		
		word	clocks;
		
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "break" );
		return( 1 );
	}
} break_inst;
{BF}


5.14 BREQ – Branch if Equal
===========================

	See BRBS 1,j


5.15 BRGE – Branch if Greater or Equal (Signed)
===============================================

	See BRBC 4,j


5.16 BRHC – Branch if Half Carry Flag is Cleared
================================================

	See BRBC 5,j


5.17 BRHS – Branch if Half Carry Flag is Set
============================================

	See BRBS 5,j


5.18 BRID – Branch if Global Interrupt is Disabled
==================================================

	See BRBC 7,j


5.19 BRIE – Branch if Global Interrupt is Enabled
=================================================

	See BRBS 7,j


5.20 BRLO – Branch if Lower (Unsigned)
======================================

	BRLO is an alias for BRCS: BRBS 1,j


5.21 BRLT – Branch if Less Than (Signed)
========================================

	See BRBS 4,j


5.22 BRMI – Branch if Minus
===========================

	See BRBS 2,j

	
5.23 BRNE – Branch if Not Equal
===============================

	See BRBC 1,j


5.24 BRPL – Branch if Plus
==========================

	See BRBC 2,j


5.25 BRSH – Branch if Same or Higher (Unsigned)
===============================================

	See BRBC 0,j


5.26 BRTC – Branch if the T Bit is Cleared
==========================================

	See BRBC 6,j


5.27 BRTS – Branch if the T Bit is Set
======================================

	See BRBS 6,j


5.28 BRVC – Branch if Overflow Cleared
======================================

	See BRBC 3,j


5.29 BRVS – Branch if Overflow Set
==================================

	See BRBS 3,j


5.30 BSET – Bit Set in SREG
===========================

{I 100101000sss1000 bset }	BSET s			SREG[s] = 1

{BS}
//
//	BSET s			SREG[s] = 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 0100 0sss 1000
		//
		state->set_sr( state->get_sr() | arg_flag_mask( opcode ));
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		int f = arg_flag( opcode );
		snprintf( buffer, max, "bset %d(%c)", f, disp_flag( f ));
		return( 1 );
	}
} bset_inst;
{BF}


5.31 BST – Bit Store from Bit in Register to T Bit in SREG
==========================================================

{I 1111101ddddd0bbb bst }	BST Rd,b		T = Rd[b]

{BS}
//
//	BST Rd,b		T = Rd[b]
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1111 101d dddd 0bbb
		//
		state->set_T(( state->read_reg( arg_d0_d31( opcode )) & arg_bit_mask( opcode )) != 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "bst r%d,%d", arg_d0_d31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} bst_inst;
{BF}


5.32 CALL – Long Call to a Subroutine
=====================================

{I 1001010jjjjj111j jjjjjjjjjjjjjjjj call }	CALL j		DS(STACK-) = PC, PC = j

{BS}
//
//	CALL j		DS(STACK-) = PC, PC = j
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010j jjjj 111j
		//	jjjj jjjj jjjj jjjj
		//
		static byte ticks[ AVR_Types ] = { 4, 4, 4, 3, 3, 0 };
	
		word	clocks,
			arg;
	
		if(( clocks = ticks[ state->mcu_type()]) == 0 ) return( 0 );
		if( state->get_pas_bits() > 8 ) clocks++;
		state->push_pc( arg_absolute( opcode, state->next_opcode()));
		return( clocks );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
{BC}
	Note:
		Probably should code to modify the output of the hex target address to match
		the value in _pas_bits and _pas_bytes.  For the moment picking the most common
		16-bit call address is a simple and broadly correct assumption.
{BS}
		snprintf( buffer, max, "call " HEX "%04X", arg_absolute( opcode, state->peek_ahead( 1 )));
		return( 2 );
	}
	//
	//	Need to override default instruction size for call.
	//
	virtual word size( void ) { return( 2 ); }

} call_inst;
{BF}


5.33 CBI – Clear Bit in I/O Register
====================================

{I 10011000aaaaabbb cbi	}	CBI a,b		IO(a)[b] = 0		(Clear bit b in IO register a)

{BS}
//
//	CBI a,b		IO(a)[b] = 0		(Clear bit b in IO register a)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 1000 aaaa abbb
		//
		word	ir;
		byte	iv;
	
		iv = state->read_io( ir = arg_a0_a31( opcode ));
		state->write_io( ir, iv & ~arg_bit_mask( opcode ));
		return( 0 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cbi %d,%d", arg_a0_a31( opcode ), arg_bit( opcode ));
		return( 1 );
	}
} cbi_inst;
{BF}


5.34 CBR – Clear Bits in Register
=================================

	CBR Rd,K

This is a alias for ANDI Rd,~K


5.35 CLC – Clear Carry Flag
===========================

Note:	The "BCLR" instruction is the core version of the eight "CL?" instructions,
	and therefore these do not require encoding individually.

	"100101001sss1000 BCLR s" where sss is the SREG bit number to clear.

		1001010010001000 clc
		1001010010011000 clz
		1001010010101000 cln
		1001010010111000 clv
		1001010011001000 cls
		1001010011011000 clh
		1001010011101000 clt
		1001010011111000 cli


5.36 CLH – Clear Half Carry Flag
================================

See section 5.7 and 5.35 above.


5.37 CLI – Clear Global Interrupt Enable Bit
============================================

See section 5.7 and 5.35 above.


5.38 CLN – Clear Negative Flag
==============================

See section 5.7 and 5.35 above.


5.39 CLR – Clear Register
=========================

This is an alias for EOR Rd,Rd.  See section 5.54.


5.40 CLS – Clear Sign Flag
==========================

See section 5.7 and 5.35 above.


5.41 CLT – Clear T Bit
======================

See section 5.7 and 5.35 above.


5.42 CLV – Clear Overflow Flag
==============================

See section 5.7 and 5.35 above.


5.43 CLZ – Clear Zero Flag
==========================

See section 5.7 and 5.35 above.


5.44 COM – One’s Complement
===========================

{I 1001010ddddd0000 com }	COM Rd		Rd = ~Rd		(Ones complement)

{BS}
//
//	COM Rd		Rd = ~Rd		(Ones complement)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 0000
		//
		byte	dr, vv;
		bool	n;
		
		vv = ~( state->read_reg( dr = arg_d0_d31( opcode )));
		state->set_V( false );
		state->set_N( n = sign( vv ));
		state->set_S( n );
		state->set_C( true );
		state->set_Z( vv == 0 );
		state->write_reg( dr, vv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "com r%d", arg_d0_d31( opcode ));
		return( 1 );
	}
} com_inst;
{BF}


5.45 CP – Compare
=================

{I 000101rdddddrrrr cp }	CP Rd,Rr		Rd - Rr			(Compare)

{BS}
//
//	CP Rd,Rr		Rd - Rr			(Compare)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 01rd dddd rrrr
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode ));
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cp r%d, r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cp_inst;
{BF}


5.46 CPC – Compare with Carry
=============================

{I 000001rdddddrrrr cpc			}	CPC Rd,Rr		Rd - Rr - C		(Compare with Carry)

{BS}
//
//	CPC Rd,Rr		Rd - Rr - C		(Compare with Carry)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0000 01rd dddd rrrr
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		rv = state->read_reg( arg_r0_r31( opcode )) + ( state->get_C()? 1: 0 );
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpc r%d, r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cpc_inst;
{BF}


5.47 CPI – Compare with Immediate
=================================

{I 0011KKKKddddKKKK cpi			}	CPI Rd,K		Rd - K			(Compare with 8-bit immediate)

{BS}
//
//	CPI Rd,K		Rd - K			(Compare with 8-bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0011 KKKK dddd KKKK
		//
		byte	dr, dv,
			rv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d16_d31( opcode ));
		rv = arg_imm8( opcode );
		bv = lsb( wv = dv - rv );
		state->set_H( borrow( dv, rv ));
		state->set_V( v = underflow( dv, rv, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpi r%d," HEX "%02X", (int)arg_d16_d31( opcode ), (int)arg_imm8( opcode ));
		return( 1 );
	}
} cpi_inst;
{BF}


5.48 CPSE – Compare Skip if Equal
=================================

{I 000100rdddddrrrr cpse		} CPSE Rd,Rr		Skip next instruction if Rd == Rr

{BS}
//
//	CPSE Rd,Rr		Skip next instruction if Rd == Rr			(Compare with 8-bit immediate)
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	0001 00rd dddd rrrr
		//
{BC}
	Note:
		The instruction definition says that this instruction will
		take 1, 2 or 3 clock cycles to complete.  In reality this
		instruction takes only 1 instruction to execute, and the
		following 1 or 2 cycles are the following instruction being
		read in, decoded (1 cycle) then an optional argument opcode
		being read in (another 1 cycle).  This creates the range of
		cycles counts the "whole instruction" takes.

		This emulation must ignore interrupts while skipping an
		instruction as this causes potential issues with 'remembering'
		if it was skipping or running when an interrupt is taken.

		A benefit of moving the skipping logic to the main loop enables
		the supporting code to be common across all instructions that
		possibly initiate an instruction skip.
{BS}
		if( state->read_reg( arg_d0_d31( opcode )) == state->read_reg( arg_r0_r31( opcode ))) state->set_skip_next();
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "cpse r%d,r%d", arg_d0_d31( opcode ), arg_r0_r31( opcode ));
		return( 1 );
	}
} cpse_inst;
{BF}


5.49 DEC – Decrement
====================

{I 1001010ddddd1010 dec			}	DEC Rd		Rd = Rd - 1

{BS}
//
//	DEC Rd		Rd = Rd - 1
//
class : public Instruction {
public:
	virtual word execute( word opcode, AVR_CPU *state ) {
		//
		//	1001 010d dddd 1010
		//
		byte	dr, dv, bv;
		word	wv;
		bool	n, v;
		
		dv = state->read_reg( dr = arg_d0_d31( opcode ));
		bv = lsb( wv = dv - 1 );
		state->set_V( v = underflow( dv, 1, bv ));
		state->set_N( n = sign( bv ));
		state->set_S( n ^ v );
		state->set_C( carry( wv ));
		state->set_Z( bv == 0 );
		state->write_reg( dr, bv );
		return( 1 );
	}
	virtual word disassemble( word opcode, AVR_CPU *state, char *buffer, int max ) {
		snprintf( buffer, max, "dec r%d", (int)arg_d0_d31( opcode ));
		return( 1 );
	}
} dec_inst;
{BF}



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{I 0000000000000000 nop			} NOP						(No Operation)
	static word op_nop( word opcode, AVR_CPU *state ) {
	{	//
	{	//	0000 0000 0000 0000
	{	//
		return( 1 );
	}

{I 00000001DDDDRRRR movw		} MOVW Rd+1:Rd,Rr+1:Rr	Rd+1:Rd = Rr+1:Rr	(Move register pair)
	static word op_movw( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 00000010ddddrrrr muls		} MULS Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x signed)
	static word op_muls( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000000110ddd0rrr mulsu		} MULSU Rd,Rr		R1:R0 = Rd x Rr		(signed = signed x unsigned)
	static word op_mulsu( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000000110ddd1rrr fmul		} FMUL Rd,Rr		R1:R0 = Rd x Rr		(unsigned (1.15) = unsigned (1.7) x unsigned (1.7))
	static word op_fmul( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000000111ddd0rrr fmuls		} FMULS Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x signed (1.7))
	static word op_fmuls( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000000111ddd1rrr fmulsu		} FMULSU Rd,Rr		R1:R0 = Rd x Rr		(signed (1.15) = signed (1.7) x unsigned (1.7))
	static word op_fmulsu( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000010rdddddrrrr sbc			} SBC Rd,Rr		Rd = Rd - Rr - C
	static word op_sbc( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 000110rdddddrrrr sub			} SUB Rd,Rr		Rd = Rd - Rr
	static word op_sub( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 001001rdddddrrrr eor			} EOR Rd,Rr		Rd = Rd ^ Rr

Remember CLR Rd is an alias for EOR Rd,Rd (both being the same register).

	static word op_eor( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 001010rdddddrrrr or			} OR Rd,Rr		Rd = Rd | Rr
	static word op_or( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 001011rdddddrrrr mov			} MOV Rd,Rr		Rd = Rr
	static word op_mov( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 0100KKKKddddKKKK sbci		} SBCI Rd,K		Rd = Rd - K - C		(Subtract 8-bit immediate and Carry)
	static word op_sbci( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 0101KKKKddddKKKK subi		} SUBI Rd,K		Rd = Rd - K		(Subtract 8-bit immediate)
	static word op_subi( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 0110KKKKddddKKKK ori			} ORI Rd,K		Rd = Rd | K		(Or with 8-bit immediate. Also: SBR Rd,K)
	static word op_ori( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0000 kkkkkkkkkkkkkkkk lds } LDS rd,k		Rd = DS(RAMPD:k)	(Data Space Immediate address)
	static word op_lds( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010111001000 lpm_r0		} LPM			R0 = PS(Z)
	static word op_lpm_r0( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0100 lpm_z		} LPM Rd,Z		Rd = PS(Z)
	static word op_lpm_z( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0101 lpm_zp		} LPM Rd,Z+		Rd = PS(Z+)
	static word op_lpm_zp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010111011000 elpm_r0		} ELPM			R0 = PS(RAMPZ:Z)
	static word op_elpm_r0( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0110 elpm_z		} ELPM Rd,Z		Rd = PS(RAMPZ:Z)
	static word op_elpm_z( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0111 elpm_zp		} ELPM Rd,Z+		Rd = PS(RAMPZ:Z+)
	static word op_elpm_zp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


{I 1001000ddddd1100 ld_x		} LD Rd,X		Rd = DS(X)
	static word op_ld_x( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd1101 ld_xp		} LD Rd,X+		Rd = DS(X+)
	static word op_ld_xp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd1110 ld_nx		} LD Rd,-X		Rd = DS(-X)
	static word op_ld_nx( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd1111 pop			} POP Rd		Rd = DS(+STACK)
	static word op_pop( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


Note:
	Documentation indicates that there are mnemonics for the
	instructions 'LD Rd,Y' and 'LD Rd,Z'.  However examining
	the binary opcode itself, these instructions should be
	recognised as actually being an alias for the instructions
	'LD RD,Y+0' and 'LD Rd,Z+0'

{I 10q0qq0ddddd1qqq ld_y_q		} LD RD,Y+q		Rd = DS(Y+q)			(See Note)
	static word op_ld_y_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd1001 ld_yp		} LD Rd,Y+		Rd = DS(Y+)
	static word op_ld_yp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd1010 ld_ny		} LD Rd,−Y		Rd = DS(-Y)
	static word op_ld_ny( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10q0qq0ddddd0qqq ld_z_q		} LD Rd,Z+q		Rd = DS(Z+q)			(See Note)
	static word op_ld_z_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0001 ld_zp		} LD Rd,Z+		Rd = DS(Z+)
	static word op_ld_zp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001000ddddd0010 ld_nz		} LD Rd,−Z		Rd = DS(-Z)
	static word op_ld_nz( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0000 kkkkkkkkkkkkkkkk sts } STS k,rd		DS(RAMPD:k) = Rd
	static word op_sts( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0100 xch			} XCH Z,Rd 		DS(Z) <-> Rd
	static word op_xch( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0101 las			} LAS Z,Rd		DS(Z) = DS(Z) | Rd, Rd = DS(Z)	(Atomic read and set)
	static word op_las( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0110 lac			} LAC Z,Rd		DS(Z) = DS(Z) & ~Rd, Rd = DS(Z)	(Atomic read and clear)
	static word op_lac( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0111 lat			} LAT Z,Rd		DS(Z) = DS(Z) ^ Rd, Rd = DS(Z)	(Atomic read and toggle)
	static word op_lat( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1100 st_x		} ST X,Rd		DS(X) = Rd
	static word op_st_x( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1101 st_xp		} ST X+,Rd		DS(X+) = Rd
	static word op_st_xp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1110 st_nx		} ST -X,Rd		DS(-X) = Rd
	static word op_st_nx( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1111 push		} PUSH Rd		DS(STACK-) = Rd
	static word op_push( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


Note:
	Documentation indicates that there are mnemonics for the
	instructions 'ST Y,Rd' and 'ST Z,Rd'.  However examining
	the binary opcode itself, these instructions should be
	recognised as actually being an alias for the instructions
	'ST Y+0,Rd' and 'ST Z+0,Rd'

{I 10q0qq1rrrrr1qqq std_y_q		} STD Y+q,Rd		DS(Y+q) = Rd			(See Note)
	static word op_std_y_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1001 st_yp		} ST Y+,Rd		DS(Y+) = Rd
	static word op_st_yp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd1010 st_ny		} ST −Y,Rd		DS(-Y) = Rd
	static word op_st_ny( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10q0qq1rrrrr0qqq std_z_q		} STD Z+q,Rd		DS(Z+q) = Rd			(See Note)
	static word op_std_z_q( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0001 st_zp		} ST Z+,Rd		DS(Z+) = Rd
	static word op_st_zp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001001ddddd0010 st_nz		} ST −Z,Rd		DS(-Z) = Rd
	static word op_st_nz( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010000001001 ijmp		} IJMP			PC = Z
	static word op_ijmp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010000011001 eijmp		} EIJMP			PC = EIND:Z
	static word op_eijmp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


Note:	The "BSET" instruction is a core version of the eight "SE?" instructions,
	and therefore these do not require encoding individually.

	"100101000sss1000 BCLR s" where sss is the SREG bit number to set.

		1001010000001000 sec
		1001010000011000 sez
		1001010000101000 sen
		1001010000111000 sev
		1001010001001000 ses
		1001010001011000 seh
		1001010001101000 set
		1001010001111000 sei

{I 10010100kkkk1011 des			} DES k			Data Encryption Action 'k'
	static word op_des( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010100001000 ret			} RET			PC = DS(+STACK)		(Pops 2 or 3 bytes as appropriate to AVR architecture)
	static word op_ret( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010100001001 icall		} ICALL Z		DS(STACK-) = PC, PC = Z	(Pushes 2 or 3 bytes)
	static word op_icall( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010100011000 reti		} RETI			PC = DS(+STACK),I = 1
	static word op_reti( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010100011001 eicall		} EICALL Z		DS(STACK-) = PC, PC = EIND:Z
	static word op_eicall( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010110001000 sleep		} SLEEP						(Put CPU into sleep mode)
	static word op_sleep( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010110101000 wdr			} WDR						(Restart Watch Dog Timer)
	static word op_wdr( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010111101000 spm			} SPM						(See section 116 in "AVR Instruction Set Manual")
{I 1001010111111000 spm			} SPM Z+ 					(See section 117 in "AVR Instruction Set Manual")
	static word op_spm( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


{I 1001010ddddd0001 neg			} NEG Rd		Rd = -Rd		(Twos complement)
	static word op_neg( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010ddddd0010 swap		} SWAP Rd		Rd[0:3] <-> Rd[7:4]	(Swap nibbles in Rd)
	static word op_swap( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010ddddd0011 inc			} INC Rd		Rd = Rd + 1		(Increment Rd)
	static word op_inc( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010ddddd0110 lsr			} LSR Rd		Rd = Rd >> 1		(Logical right shift)
	static word op_lsr( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010ddddd0111 ror			} ROR Rd		C -> Rd -> C		(Rotate right Rd through Carry)
	static word op_ror( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1001010kkkkk110k kkkkkkkkkkkkkkkk jmp } JMP k		PC = k
	static word op_jmp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10010111kkddkkkk sbiw		} SBIW Rp,k		Rd+1:Rd -= k		(where "d=24+(dd<<1)" and k is unsigned 6 bit value)
	static word op_sbiw( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011001aaaaabbb sbic		} SBIC a,b		If IO(a)[b] == 0 skip	(Skip next instruction if bit b in IO register a is clear)
	static word op_sbic( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011010aaaaabbb sbi			} SBI a,b		IO(a)[b] = 1		(Set bit b in IO register a)
	static word op_sbi( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10011011aaaaabbb sbis		} SBIS a,b		If IO(a)[b] == 1 skip	(Skip next instruction if bit b in IO register a is set)
	static word op_sbis( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 100111rdddddrrrr mul			} MUL Rd,Rr		R1:R0 = Rr x Rd		(unsigned = unsigned x unsigned)
	static word op_mul( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10110aadddddaaaa in			} IN Rd,a		Rd = IO(a)		(Output register to IO address)
	static word op_in( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 10111aadddddaaaa out			} OUT a,Rd		IO(a) = Rd		(Read register from IO address)
	static word op_out( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1100jjjjjjjjjjjj rjmp		} RJMP j		PC = PC + j		(Relative jump, j is signed 12 bit immediate)
	static word op_rjmp( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1101jjjjjjjjjjjj rcall		} RCALL j		DS(STACK-) = PC, PC = PC + j (Relative call, j is signed 12 bit immediate)
	static word op_rcall( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1110KKKKddddKKKK ldi			} LDI Rd,K		Rd = K			(Load register with 8 bit immediate)
	static word op_ldi( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


{I 1111110ddddd0bbb sbrc		} SBRC Rd,b		Skip next if Rd[b] == 0
	static word op_sbrc( word opcode, AVR_CPU *state ) {
		return( 0 );
	}

{I 1111111ddddd0bbb sbrs		} SBRS Rd,b		Skip next if Rd[b] == 1
	static word op_sbrs( word opcode, AVR_CPU *state ) {
		return( 0 );
	

{I 1001010110111000 reserved		} 			Reserved 
{I 10010101001x1000 reserved		} 			Reserved
{I 1001010101xx1000 reserved		} 			Reserved
{I 1001010ddddd0100 reserved		} 			Reserved
{I 11111xxddddd1bbb reserved		} 			Reserved
	static word op_reserved( word opcode, AVR_CPU *state ) {
		return( 0 );
	}


End of Instruction data.
========================
